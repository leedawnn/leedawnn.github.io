{"componentChunkName":"component---src-pages-series-jsx","path":"/series/","result":{"data":{"site":{"siteMetadata":{"title":"leedawn"}},"allMarkdownRemark":{"group":[{"fieldValue":"CSR","totalCount":1},{"fieldValue":"ISR","totalCount":1},{"fieldValue":"MPA","totalCount":1},{"fieldValue":"SPA","totalCount":1},{"fieldValue":"SSG","totalCount":1},{"fieldValue":"SSR","totalCount":2},{"fieldValue":"ajax","totalCount":1},{"fieldValue":"async","totalCount":1},{"fieldValue":"await","totalCount":1},{"fieldValue":"axios","totalCount":1},{"fieldValue":"components","totalCount":2},{"fieldValue":"cookie","totalCount":1},{"fieldValue":"fetch","totalCount":1},{"fieldValue":"javascript","totalCount":1},{"fieldValue":"jwt","totalCount":1},{"fieldValue":"login","totalCount":1},{"fieldValue":"nextjs","totalCount":1},{"fieldValue":"pure function","totalCount":1},{"fieldValue":"react","totalCount":2},{"fieldValue":"session","totalCount":1},{"fieldValue":"try~catch","totalCount":1}],"nodes":[{"excerpt":"Ajax (Asynchronous Javascript and XML) Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있다. 즉 Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹페이지의 일부분만 표시 할 수 있다. 동작 방식 Ajax는  객체를 사용하여 서버와 통신한다. 이 객체를 통해 데이터를 …","fields":{"slug":"/ajax-axios/"},"frontmatter":{"date":"March 13, 2024","update":"Mar 13, 2024","title":"🦚 Ajax와 fetch, Axios는 어떻게 다를까?","tags":["ajax","fetch","axios"],"series":null}},{"excerpt":"자바스크립트에서 에러가 발생하면 스크립트는 죽고, 콘솔에 에러가 출력된다. 그러나 문을 사용하면 스크립트가 죽는 걸 방지하고, 에러를 잡아서(catch) 예외 처리를 할 수 있게 된다. try...catch문 try...catch문의 동작은 다음과 같다. 먼저,  안의 코드가 실행된다. 에러가 없다면,  안의 마지막 줄까지 실행되고,  블록은 건너뛴다. …","fields":{"slug":"/error-handling/"},"frontmatter":{"date":"March 07, 2024","update":"Mar 07, 2024","title":"⚠️ 자바스크립트의 예외 처리","tags":["javascript","try~catch","async","await"],"series":"javascript"}},{"excerpt":"MPA(Multiple Page Application)이란? 여러 개의 Page로 구성된 Application이다. MAP는 SSR 방식으로 렌더링한다.\n새로운 페이지를 요청할 때마다 서버에서 렌더링된 정적 리소스(HTML, CSS, Javascript)가 다운로드된다. 페이지를 이동하거나 새로고침하면 전체 페이지를 다시 렌더링한다. MPA의 장점 SEO…","fields":{"slug":"/spa-mpa/"},"frontmatter":{"date":"March 05, 2024","update":"Mar 05, 2024","title":"🤔 SPA vs MPA와 SSR vs CSR","tags":["MPA","SPA","CSR","SSR"],"series":null}},{"excerpt":"","fields":{"slug":"/nextjs-rendering/"},"frontmatter":{"date":"March 05, 2024","update":"Mar 05, 2024","title":"↗️ Next.js의 렌더링 방식 이해하기","tags":["nextjs","SSR","SSG","ISR"],"series":"nextjs"}},{"excerpt":"순수 함수란 무엇인가? 순수 함수란 사이드 이펙트가 없는 함수, 즉 함수의 실행이 외부에 영향을 끼치지 않는 함수를 뜻하고 입력으로 전달된 값을 수정하지 않는 불변성을 가지고 있다. 따라서 순수함수는 어떠한 전달인자가 주어지더라도 항상 똑같은 값이 리턴됨을 보장한다. 사이드 이펙트를 만들지 않는다. 함수는 입력받은 값만을 가지고 결과를 반환하며, 그 외 …","fields":{"slug":"/pure-components/"},"frontmatter":{"date":"March 04, 2024","update":"Mar 04, 2024","title":"🐳 React에서의 순수 컴포넌트","tags":["react","pure function","components"],"series":"react"}},{"excerpt":"로그인을 구현할 때 어떤 방법이 있을까? 프론트엔드에서 로그인을 구현하는 방법에는 여러 가지가 있다. 세션 기반 인증 : 사용자가 로그인을 하면 서버는 사용자의 정보를 세션에 저장하고, 클라이언트에 세션 ID를 쿠키로 전송한다. 클라이언트는 이 쿠키를 보관하고 있다가 다음 요청 시 쿠키를 함께 보내 서버에서 인증을 받는다. 서버는 세션 ID를 통해 사용자…","fields":{"slug":"/login-logics/"},"frontmatter":{"date":"February 28, 2024","update":"Feb 28, 2024","title":"🔧 로그인 로직 이해하기","tags":["login","jwt","session","cookie"],"series":null}},{"excerpt":"컴포넌트를 분리하는 방법에는 어떤 것이 있을까? 컴포넌트를 분리하는 방법론들에 따라, 컴포넌트를 분리하는 \"기준\"이 달라지게 된다. 보통 컴포넌트를 분리하는 방법론은 아래와 같이 나뉜다. 컴포넌트의 관심사 분리(Separation of Concerns, SoC) headless 컴포넌트 SOLID, 단일 책임의 원칙 이 방법론들은 각각 어떤 기준을 가지고…","fields":{"slug":"/react-components/"},"frontmatter":{"date":"February 26, 2024","update":"Feb 26, 2024","title":"🚀 React에서 컴포넌트를 분리하는 기준","tags":["react","components"],"series":"react"}}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}