{"componentChunkName":"component---src-templates-post-jsx","path":"/login-logics/","result":{"data":{"site":{"siteMetadata":{"title":"leedawn"}},"markdownRemark":{"id":"ccfbbea4-08d5-5f3b-87fa-bdf6e1f09d59","excerpt":"로그인을 구현할 때 어떤 방법이 있을까? 프론트엔드에서 로그인을 구현하는 방법에는 여러 가지가 있다. 세션 기반 인증 : 사용자가 로그인을 하면 서버는 사용자의 정보를 세션에 저장하고, 클라이언트에 세션 ID를 쿠키로 전송한다. 클라이언트는 이 쿠키를 보관하고 있다가 다음 요청 시 쿠키를 함께 보내 서버에서 인증을 받는다. 서버는 세션 ID를 통해 사용자…","html":"<h2>로그인을 구현할 때 어떤 방법이 있을까?</h2>\n<p>프론트엔드에서 로그인을 구현하는 방법에는 여러 가지가 있다.</p>\n<ul>\n<li><strong>세션 기반 인증</strong> : 사용자가 로그인을 하면 서버는 사용자의 정보를 세션에 저장하고, 클라이언트에 세션 ID를 쿠키로 전송한다. 클라이언트는 이 쿠키를 보관하고 있다가 다음 요청 시 쿠키를 함께 보내 서버에서 인증을 받는다. 서버는 세션 ID를 통해 사용자의 정보를 찾아 인증한다.</li>\n<li><strong>토큰 기반 인증 (jwt ..)</strong> : 사용자가 로그인을 하면 서버는 사용자의 정보를 토큰에 담아 클라이언트에게 전송한다. 클라이언트는 이 토큰을 보관하고 있다가 다음 요청 시 토큰을 함께 보내 서버에서 인증을 받는다. 서버는 토큰을 해독해 사용자의 정보를 확인하고 인증한다.</li>\n<li><strong>OAuth</strong> : 사용자가 이미 가입한 다른 서비스의 계정을 이용해 로그인하는 방법이다. 예를 들어, 구글이나 페이스북(meta) 계정으로 로그인하는 것이 이에 해당한다. 이 방식은 OAuh 프로토콜을 사용하며, 사용자가 서비스에 개인 정보를 제공하는 것 없이도 인증을 할 수 있다.</li>\n<li><strong>Firebase Auth</strong> : Firebase는 인증에 필요한 백엔드 서비스를 제공한다. 클라이언트 단에서 REST API를 사용하기만 하면 인증을 구현할 수 있다.</li>\n</ul>\n<p>OAuth와 같은 다른 서비스를 이용하여 인증을 구현하는 방식을 제외하고, JWT와 세션을 이용한 로그인 로직에 대해 알아보자.</p>\n<h2>JWT (JSON Web Token)</h2>\n<ul>\n<li>\n<p><strong>구현 방법</strong></p>\n<ol>\n<li>사용자가 로그인에 성공하면 서버에서 JWT를 생성하여 사용자에게 반환한다.</li>\n<li>사용자는 이 JWT를 클라이언트 측에 저장하고, 이후 요청에 대해 HTTP 헤더에 포함시켜 인증한다.</li>\n<li>서버는 이 토큰을 디코딩하여 유효성을 검증하고 요청을 처리한다.</li>\n</ol>\n</li>\n<li>\n<p><strong>장점</strong></p>\n<ul>\n<li>서버 측에서 세션 상태를 유지할 필요가 없으므로 Stateless하고 확장성이 좋다.</li>\n<li>또한, 토큰은 클라이언트 측에서 저장되므로 서버의 부하를 줄일 수 있다.</li>\n</ul>\n</li>\n<li>\n<p><strong>단점</strong></p>\n<ul>\n<li>JWT는 상대적으로 크기가 크므로, 매 요청마다 토큰을 포함시켜 보내야 하기 때문에 네트워크 부하가 생길 수 있다.</li>\n<li>또한, 한번 발급된 토큰은 유효기간이 만료될 때까지 계속 유효하므로 보안 문제가 발생할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h2>세션</h2>\n<ul>\n<li>\n<p><strong>구현 방법</strong></p>\n<ol>\n<li>사용자가 로그인에 성공하면 서버에서 세션 ID를 생성하여 사용자에게 반환한다.</li>\n<li>이 세션 ID와 매칭되는 사용자 정보를 서버에 저장한다.</li>\n<li>사용자는 이후 요청에 대해 세션 ID를 포함시켜 서버에 전송하고, 서버는 이 세션 ID를 통해 사용자를 식별한다.</li>\n</ol>\n</li>\n<li>\n<p><strong>장점</strong></p>\n<ul>\n<li>사용자 정보는 서버에 저장되므로, 보안성이 상대적으로 높다.</li>\n<li>서버에서 사용자의 상태 정보를 관리하므로 상세한 컨트롤이 가능하다.</li>\n</ul>\n</li>\n<li>\n<p><strong>단점</strong></p>\n<ul>\n<li>사용자가 많아질수록 서버의 메모리를 많이 차지하게 되므로 확장성에 문제가 생길 수 있다.</li>\n<li>서버 기반의 인증 방식이므로 서버의 부하가 증가할 수 있다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"🔧 로그인 로직 이해하기","date":"February 28, 2024","update":"February 28, 2024","tags":["login","jwt","session","cookie"],"series":null},"fields":{"slug":"/login-logics/","readingTime":{"minutes":4.72}}},"seriesList":{"edges":[{"node":{"id":"ccfbbea4-08d5-5f3b-87fa-bdf6e1f09d59","fields":{"slug":"/login-logics/"},"frontmatter":{"title":"🔧 로그인 로직 이해하기"}}},{"node":{"id":"5dda7795-372e-5c0c-8354-aab58362862d","fields":{"slug":"/pure-components/"},"frontmatter":{"title":"🐳 React에서의 순수 컴포넌트"}}},{"node":{"id":"bbdd17bd-3d59-59a2-aea8-c0141bf3d3c1","fields":{"slug":"/nextjs-rendering/"},"frontmatter":{"title":"↗️ Next.js의 렌더링 방식 이해하기"}}},{"node":{"id":"e1bbc6c4-39e7-51cb-a5df-f9adfed5b6fc","fields":{"slug":"/spa-mpa/"},"frontmatter":{"title":"🤔 SPA vs MPA와 SSR vs CSR"}}}]},"previous":{"fields":{"slug":"/react-components/"},"frontmatter":{"title":"🚀 React에서 컴포넌트를 분리하는 기준"}},"next":{"fields":{"slug":"/pure-components/"},"frontmatter":{"title":"🐳 React에서의 순수 컴포넌트"}}},"pageContext":{"id":"ccfbbea4-08d5-5f3b-87fa-bdf6e1f09d59","series":null,"previousPostId":"5e6ba77f-d46d-5a11-9dc8-7d9bcaf2604a","nextPostId":"5dda7795-372e-5c0c-8354-aab58362862d"}},"staticQueryHashes":[],"slicesMap":{}}