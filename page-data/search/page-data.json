{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"Ajax (Asynchronous Javascript and XML) Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있다. 즉 Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹페이지의 일부분만 표시 할 수 있다. 동작 방식 Ajax는  객체를 사용하여 서버와 통신한다. 이 객체를 통해 데이터를 …","fields":{"slug":"/ajax-axios/"},"frontmatter":{"date":"March 13, 2024","title":"🦚 Ajax와 fetch, Axios는 어떻게 다를까?","tags":["ajax","fetch","axios"]},"rawMarkdownBody":"\r\n## Ajax (Asynchronous Javascript and XML)\r\n\r\nAjax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있다. 즉 Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹페이지의 일부분만 표시 할 수 있다.\r\n\r\n### 동작 방식\r\n\r\nAjax는 `XMLHttpRequest` 객체를 사용하여 서버와 통신한다. 이 객체를 통해 데이터를 비동기적으로 교환할 수 있으며, 페이지 전체를 새로고침하지 않고도 일부분만을 업데이트할 수 있다.\r\n\r\n### 사용법\r\n\r\n```js\r\nconst xhr = new XMLHttpRequest() // XMLHttpRequest 객체 생성\r\n\r\nxhr.open(\"GET\", \"url-to-the-server\", true) // 요청 초기화 (HTTP 요청 메서드, 요청을 보낼 서버의 url, 비동기적으로 요청할 것인지 boolean)\r\n// 응답 처리 이벤트 핸들러 (xhr.readyState === 4는 요청 완료되었음을 나타냄)\r\nxhr.onreadystatechage = function () {\r\n  if (xhr.readyState === 4 && xhr.status === 200) {\r\n    console.log(xhr.responseText) // 서버로부터 받은 데이터 처리\r\n  }\r\n}\r\n\r\nxhr.send() // 요청 전송\r\n```\r\n\r\n### 한계\r\n\r\nAjax는 `XMLHttpRequest` 객체를 사용하여 비동기 통신을 구현한다. 하지만 사용법이 복잡하고, 콜백 지옥(callback hell)과 같은 문제가 발생할 수 있다. 또한 JSON 데이터를 처리하기 위한 추가적인 변환 작업이 필요하다.\r\n\r\n### Fetch의 등장 배경\r\n\r\nFetch API는 `Promise`를 기반으로 하여 비동기 통신을 더욱 간결하고 직관적으로 만들 수 있게 해준다. Fetch는 `XMLHttpRequest`보다 더 유연하고 강력한 기능을 제공하며, 직접적으로 JSON을 지원하여 데이터 처리가 훨씬 간편해졌다.\r\n\r\n## Fetch API\r\n\r\nFetch API는 브라우저의 `window` 객체에 내장되어 있으며, `Request`와 `Response` 객체를 사용하여 요청과 응답을 쉽게 처리할 수 있다.\r\n\r\n### 사용법\r\n\r\n```js\r\nfetch(url, options)\r\n  .then(response => console.log(\"response: \", response.json())) // JSON 데이터로 변환\r\n  .catch(error => console.log(\"error: \", error))\r\n```\r\n\r\nfetch는 첫번째 인자로 `url`, 두번째 인자로 `옵션 객체`를 받고, `Promise` 타입의 객체를 반환한다. 반환된 객체는 API 호출이 성공했을 경우에는 응답(response) 객체를 `resolve`하고, 실패했을 경우에는 예외(error) 객체를 `reject`한다.\r\n\r\n### 한계\r\n\r\nFetch API는 많은 개선점을 제공하지만, 여전히 몇 가지 한계가 있다.  \r\n예를 들어, Fetch는 요청 시간 초과(timeouts)를 직접적으로 지원하지 않는다. 또한 브라우저 호환성 문제와 일부 기능(진행 상태 추적 등)에 대한 제한이 있을 수 있다.\r\n\r\n### Axios의 등장 배경\r\n\r\nAxios는 Fetch의 모든 장점을 가지면서도, Fetch의 한계를 극복하기 위해 등장했다. Axios는 요청 시간 초과 설정, 요청 취소, HTTP 상태 코드에 따른 자동 변환, 진행 상태 추적 등 추가적인 기능을 제공한다. 또한 브라우저뿐만 아니라 Node.js 환경에서도 사용할 수 있어서 서버 사이드와 클라이언트 사이드 모두 사용된다.\r\n\r\n## Axios\r\n\r\nAxios는 HTTP 요청을 보내기 위한 자바스크립트 라이브러리이다. Axios는 내부적으로 `XMLHttpRequest`를 사용하지만, `Promise` 기반의 API를 제공하여 보다 쉬운 비동기 처리를 가능하게 한다. 또한, 요청과 응답을 JSON 형태로 자동 변환해주거나 에러 처리 등과 추가적인 기능을 제공한다. 보통 아래와 같이 `async/await`와 함께 사용한다.\r\n\r\nFetch API와 비교했을 때 차이점을 좀 더 자세히 알아보자면, 아래와 같다.\r\n\r\n- **자동 JSON 변환**\r\n\r\n  Axios는 `response`를 자동으로 JSON 형태로 변환해준다. 반면, Fetch API는 `response`가 도착했을 때, `.json()`을 호출하여 수동으로 변환해야한다.\r\n\r\n- **에러 처리**\r\n\r\n  Fetch API는 네트워크 오류가 발생하지 않는 한 요청 실패를 액션이 실패로 간주하지 않는다. 즉, 404나 500 같은 서버 에러 상태에서도 `.then()`을 실행한다. 반면, Axios는 2xx 범위 외의 HTTP 상태 코드를 받으면 자동으로 에러를 발생시킨다.\r\n\r\n- **브라우저 지원**\r\n\r\n  Fetch API는 일부 구형 브라우저에서는 기본적으로 지원되지 않을 수 있다. 반면, Axios는 모든 브라우저에서 작동하도록 Promise API를 사용한다.\r\n\r\n- **timeout 설정**\r\n\r\n  Axios는 요청 타임아웃을 설정하는 옵션이 내장되어 있다. Fetch API에서는 이를 직접 구현해야한다.\r\n\r\n### 사용법\r\n\r\n```js\r\nconst fetchData = async () => {\r\n  try {\r\n    const response = await axios.get(\"url-to-the-server\")\r\n    console.log(response.data)\r\n  } catch (error) {\r\n    console.error(\"Error! : \", error)\r\n  }\r\n}\r\n```\r\n\r\n더 자세한 사용법을 알고싶다면, [**⚠️ 자바스크립트의 예외 처리**](https://leedawnn.github.io/error-handling/) 글을 참고!\r\n"},{"excerpt":"자바스크립트에서 에러가 발생하면 스크립트는 죽고, 콘솔에 에러가 출력된다. 그러나 문을 사용하면 스크립트가 죽는 걸 방지하고, 에러를 잡아서(catch) 예외 처리를 할 수 있게 된다. try...catch문 try...catch문의 동작은 다음과 같다. 먼저,  안의 코드가 실행된다. 에러가 없다면,  안의 마지막 줄까지 실행되고,  블록은 건너뛴다. …","fields":{"slug":"/error-handling/"},"frontmatter":{"date":"March 07, 2024","title":"⚠️ 자바스크립트의 예외 처리","tags":["javascript","try~catch","async","await"]},"rawMarkdownBody":"\r\n자바스크립트에서 에러가 발생하면 스크립트는 죽고, 콘솔에 에러가 출력된다.  \r\n그러나 `try...catch`문을 사용하면 스크립트가 죽는 걸 방지하고, 에러를 잡아서(catch) 예외 처리를 할 수 있게 된다.\r\n\r\n## try...catch문\r\n\r\n```js\r\ntry {\r\n  // ...\r\n} catch (error) {\r\n  // 에러 핸들링\r\n}\r\n```\r\n\r\n**try...catch문의 동작은 다음과 같다.**\r\n\r\n1. 먼저, `try {...}` 안의 코드가 실행된다.\r\n2. 에러가 없다면, `try` 안의 마지막 줄까지 실행되고, `catch` 블록은 건너뛴다.\r\n3. 에러가 있다면, `try` 안 코드의 실행이 중단되고, `catch(error)` 블록으로 제어 흐름이 넘어간다. 변수 error는 무슨 일이 일어났는지에 대한 설명이 담긴 에러 객체를 포함한다.\r\n\r\n`try {...}` 블록 안에서 에러가 발생해도 `catch`에서 에러를 처리하기 때문에 스크립트는 죽지 않는다.\r\n\r\n### `try...catch`는 오직 런타임 에러에만 동작한다.\r\n\r\n`try...catch`는 실행 가능한(runnable) 코드에만 동작한다. 실행 가능한 코드는 문법적으로 맞는 자바스크립트 코드를 의미한다.  \r\n자바스크립트 엔진은 코드를 읽고 난 후 코드를 실행한다. 코드를 읽는 중에 발생하는 에러는 'parse-time 에러'라고 부르는데, 엔진은 이 코드를 이해할 수 없기 때문에 parse-time 에러는 코드 안에서 복구가 불가능하다.\r\n\r\n`try...catch`는 유효한 코드에서 발생하는 에러만 처리할 수 있다. 이런 에러를 '런타임 에러(runtime error)' 혹은 '예외(exception)'라고 부른다.\r\n\r\n### `try...catch`문은 동기적으로 동작한다.\r\n\r\n`setTimeout`처럼 스케줄 된 코드에서 발생한 예외는 `try...catch`문에서 잡아낼 수 없다.\r\n\r\n```js\r\ntry {\r\n  setTimeout(function () {\r\n    noSuchVariable // 스크립트는 여기서 죽는다.\r\n  }, 1000)\r\n} catch (e) {\r\n  alert(\"작동 멈춤\")\r\n}\r\n```\r\n\r\n`setTimeout`에 넘겨진 익명 함수는 `try...catch`를 떠난 다음에서야 실행되기 때문이다.  \r\n스케줄 된 함수 내부의 예외를 잡으려면, `try...catch`를 반드시 함수 내부에 구현해야한다.\r\n\r\n```js\r\nsetTimeout(function () {\r\n  try {\r\n    noSuchVariable // 이제 try...catch에서 에러를 핸들링 할 수 있다!\r\n  } catch {\r\n    alert(\"에러를 잡았습니다!\")\r\n  }\r\n}, 1000)\r\n```\r\n\r\n### 에러 객체\r\n\r\n에러가 발생하면 자바스크립트는 에러 상세내용이 담긴 객체를 생성한다. 그 후, `catch` 블록에 이 객체를 인수로 전달한다.\r\n\r\n```js\r\ntry {\r\n  // ...\r\n} catch (e) {\r\n  // <-- 에러 객체\r\n  // ...\r\n}\r\n```\r\n\r\n내장 에러 전체와 에러 객체는 두 가지 주요 프로퍼티를 가진다.\r\n\r\n- `name`\r\n  에러 이름. 정의 되지 않은 변수 때문에 발생한 에러라면 `\"ReferenceError\"`가 이름이 된다.\r\n- `message`\r\n  에러 상세 내용을 담고 있는 문자 메시지.\r\n\r\n예시:\r\n\r\n```js\r\ntry {\r\n  lalala // 에러, 변수가 정의되지 않음!\r\n} catch (e) {\r\n  alert(e.name) // ReferenceError\r\n  alert(e.message) // lalala is not defined\r\n\r\n  // 에러 전체를 보여줄 수도 있다.\r\n  // 이때, 에러 객체는 \"name: message\" 형태의 문자열로 변환된다.\r\n  alert(e) // ReferenceError: lalala is not defined\r\n}\r\n```\r\n\r\n### `throw` 연산자\r\n\r\n`throw`문의 주요 용도는 크게 두 가지가 있다.\r\n\r\n1. 커스텀 에러 메시지\r\n   throw문을 사용하면 특정 조건에서 커스텀 에러 메시지를 생성할 수 있다. 이는 코드를 디버깅하는데 도움이 된다.  \r\n   또한, 특정 조건에서 발생하는 에러를 사용자에게 더 친절하게 전달할 수 있게 해준다.\r\n\r\n```js\r\nif (!isValid) {\r\n  throw new Error(\"입력 값이 유효하지 않습니다.\")\r\n}\r\n```\r\n\r\n2. 예외를 강제로 발생시키기\r\n   코드의 실행을 강제로 중단하고, 해당 에러를 `catch` 블록으로 전달할 수 있다. 이는 특정 조건에서 프로그램의 실행을 중단하고, 이를 적절하게 처리하고 싶을 때 유용하다.\r\n\r\n### 에러 다시 던지기\r\n\r\n```js\r\nlet json = '{ \"age\": 30 }' // 불완전한 데이터\r\n\r\ntry {\r\n  user = JSON.parse(json) // user 앞에 let을 붙이는 걸 잊음\r\n\r\n  // ...\r\n} catch (e) {\r\n  alert(\"JSON Error: \" + e) // JSON Error: ReferenceError: user is not defined\r\n  // 실제로는 JSON Error가 아님\r\n}\r\n```\r\n\r\n위 코드에서 '불완전한 데이터'를 다루려는 목적으로 `try...catch`를 사용했다. 그런데 catch는 원래 try 블록에서 발생한 모든 에러를 잡으려는 목적으로 만들어졌다. 그런데 위 예시에서 catch는 예상치 못한 에러를 잡아주긴 했지만, 에러 종류와 상관없이 `\"JSON Error\"` 메시지를 보여준다. 이렇게 에러 종류와 관계없이 동일한 방식으로 에러를 처리하는 것은 디버깅을 어렵게 만들기 때문에 좋지 않다.\r\n\r\n이런 문제를 피하고자 '**다시 던지기(rethrowing)**' 기술을 사용한다. 규칙은 간단하다.\r\n\r\n**catch는 알고 있는 에러만 처리하고 나머지는 '다시 던져야'한다.**\r\n\r\n1. catch가 모든 에러를 받는다.\r\n2. catch(e) {...} 블록 안에서 에러 객체 e를 분석한다.\r\n3. 에러 처리 방법을 알지 못하면 throw e를 한다.\r\n\r\n보통 에러 타입을 `instanceof` 명령어로 체크한다.\r\n\r\n```js\r\ntry {\r\n  user = {\r\n    /*...*/\r\n  }\r\n} catch (e) {\r\n  if (e instanceof ReferenceError) {\r\n    alert(\"ReferenceError\") // 정의되지 않은 변수에 접근하여 'ReferenceError' 발생\r\n  }\r\n}\r\n```\r\n\r\n## async와 await\r\n\r\nasync와 await를 사용하면 Promise를 좀 더 편하게 사용할 수 있다.\r\n\r\n### async 함수\r\n\r\n```js\r\nasync function f() {\r\n  return 1\r\n}\r\n```\r\n\r\n`async`는 function 앞에 위치한다.\r\n\r\nfunction 앞에 `async`를 붙이면 해당 함수는 항상 Promise를 반환한다. Promise가 아닌 값을 반환하더라도 이행(resolved) 상태의 Promise로 값을 감싸 이행된 Promise가 반환되도록 한다.\r\n\r\n```js\r\nasync function f() {\r\n  return 1\r\n}\r\n\r\nf().then(alert) // 1\r\n```\r\n\r\n`async`가 붙은 함수는 반드시 Promise를 반환하고, Promise가 아닌 것은 Promise로 감싸 반환한다. 또다른 키워드 `await`는 `async` 함수 안에서만 동작한다.\r\n\r\n### await\r\n\r\n```js\r\n// await는 async 함수 안에서만 동작한다.\r\nlet value = await promise\r\n```\r\n\r\n자바스크립트는 `await` 키워드를 만나면 Promise가 처리될 때까지 기다린다. 결과는 그 이후 반환된다.\r\n\r\n1초 후 이행되는 Promise를 예시로 `await`가 어떻게 동작하는지 살펴보자.\r\n\r\n```js\r\nasync function f() {\r\n  let promise = new Promise((resolve, reject) => {\r\n    setTimeout(() => resolve(\"완료!\"), 1000)\r\n  })\r\n\r\n  let result = await promise // Promise가 이행될 때까지 기다림\r\n\r\n  alert(result) // 완료!\r\n}\r\n```\r\n\r\n함수를 호출하고, 함수 본문이 실행되는 도중에 `await` 키워드를 만나면 실행이 잠시 중단되었다가 Promise가 처리되면 실행이 재개된다. 이때 Promise 객체의 result 값이 변수 result에 할당된다. 따라서 위 예시를 실행하면 1초 뒤에 `\"완료!\"`가 출력된다.\r\n\r\n`await`는 말 그대로 Promise가 처리될 때까지 함수 실행을 기다리게 만든다. Promise가 처리되면 그 결과와 함께 실행이 재개된다. Promise가 처리되길 기다리는 동안엔 엔진이 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있기 때문에, CPU 리소스가 낭비되지 않는다.\r\n\r\n`await`는 `promise.then`보다 더 세련되게 Promise의 result값을 얻을 수 있도록 하는 문법이다.\r\n`promise.then`보다 가독성이 좋고 사용하기도 쉽다.\r\n\r\n### 에러 핸들링\r\n\r\nPromise가 정상적으로 이행되면 `await promise`는 Promise 객체의 result에 저장된 값을 반환한다. 반면 Promise가 거부되면 마치 throw문을 작성한 것처럼 에러가 던져진다.\r\n\r\n```js\r\nasync function f() {\r\n  await Promise.reject(new Error(\"에러 발생!\"))\r\n}\r\n\r\n// 위 코드는 아래 코드와 동일하다.\r\nasync function f() {\r\n  throw new Error(\"에러 발생!\")\r\n}\r\n```\r\n\r\n실제 상황에선 Promise가 거부 되기 전에 약간의 시간이 지체되는 경우가 있다. 이런 경우엔 `await`가 에러를 던지기 전에 지연이 발생한다.\r\n\r\nawait가 던진 에러는 throw가 던진 에러를 잡을 때처럼 `try...catch`를 사용해 잡을 수 있다.\r\n\r\n```js\r\nasync function f() {\r\n  try {\r\n    let response = await fetch(\"http://유효하지-않은-주소\")\r\n  } catch (e) {\r\n    alert(e) // TypeError: failed to fetch\r\n  }\r\n}\r\n\r\nf()\r\n```\r\n\r\n`try...catch`가 없으면 아래 예시의 async 함수 `f()`를 호출해 만든 Promise가 거부 상태가 된다. `f()`에 `.catch`를 추가하면 거부된 Promise를 처리할 수 있다.\r\n\r\n```js\r\nasync function f() {\r\n  let response = await fetch(\"http://유효하지-않은-주소\")\r\n}\r\n\r\n// f()는 거부 상태의 프라미스가 된다.\r\nf().catch(alert) // TypeError: failed to fetch\r\n```\r\n\r\n### async/await는 Promise.all과도 함께 쓸 수 있다.\r\n\r\n여러 개의 Promise가 모두 처리되길 기다려야 하는 상황이라면 이 Promise들을 `Promise.all`로 감싸고 여기에 `await`를 붙여 사용할 수 있다.\r\n\r\n```js\r\n// Promise 처리 결과가 담긴 배열을 기다린다.\r\nlet results = await Promise.all([\r\n  fetch(url1),\r\n  fetch(url2),\r\n  ...\r\n])\r\n```\r\n\r\n실패한 Promise에서 발생한 에러는 보통 에러와 마찬가지로 `Promise.all`로 전파된다. 에러 때문에 생긴 예외는 `try...catch`로 감싸 잡을 수 있다.\r\n\r\n## 그래서 실무에서는 어떻게 써야해?\r\n\r\n보통 `axios`를 이용해서 API 요청을 보내고 받아온다. 아래는 GPT-4에게 `try~catch`문과  \r\n`async/await`를 적절하게 사용한 best practice 작성을 부탁한 코드다.\r\n\r\n### 1. 타입 정의\r\n\r\n```ts\r\ninterface ApiResponse {\r\n  success: boolean\r\n  data: any // 실제 응답 구조에 맞게 타입을 상세하게 정의\r\n}\r\n```\r\n\r\n### 2. Axios 인스턴스 생성\r\n\r\n```ts\r\nimport axios from \"axios\"\r\n\r\nconst client = axios.create({\r\n  baseURL: \"https://api.example.com\", // 보통 서버리스 함수 등으로 API 숨김. 여기선 skip\r\n  headers: {\r\n    \"Content-Type\": \"application/json\",\r\n  },\r\n})\r\n```\r\n\r\n### 3. API 요청 함수 작성\r\n\r\n```ts\r\nasync function fetchSomeData(): Promise<ApiResponse> {\r\n  try {\r\n    const response = await client.get<ApiResponse>(\"/data\")\r\n    return response.data\r\n  } catch (error) {\r\n    if (axios.isAxiosError(error)) {\r\n      // Axios 에러 처리\r\n      console.error(\"Axios error:\", error.response)\r\n    } else {\r\n      // 기타 에러 처리\r\n      console.error(\"Unexpected error:\", error)\r\n    }\r\n    throw error\r\n  }\r\n}\r\n```\r\n\r\n### 4. 사용 예시\r\n\r\n```ts\r\nasync function main() {\r\n  try {\r\n    const data = await fetchSomeData()\r\n    console.log(data)\r\n  } catch (error) {\r\n    console.error(\"Error fetching data:\", error)\r\n  }\r\n}\r\n\r\nmain()\r\n```\r\n"},{"excerpt":"MPA(Multiple Page Application)이란? 여러 개의 Page로 구성된 Application이다. MAP는 SSR 방식으로 렌더링한다.\n새로운 페이지를 요청할 때마다 서버에서 렌더링된 정적 리소스(HTML, CSS, Javascript)가 다운로드된다. 페이지를 이동하거나 새로고침하면 전체 페이지를 다시 렌더링한다. MPA의 장점 SEO…","fields":{"slug":"/spa-mpa/"},"frontmatter":{"date":"March 05, 2024","title":"🤔 SPA vs MPA와 SSR vs CSR","tags":["MPA","SPA","CSR","SSR"]},"rawMarkdownBody":"\r\n## MPA(Multiple Page Application)이란?\r\n\r\n- 여러 개의 Page로 구성된 Application이다.\r\n- MAP는 SSR 방식으로 렌더링한다.\r\n  새로운 페이지를 요청할 때마다 서버에서 렌더링된 정적 리소스(HTML, CSS, Javascript)가 다운로드된다. 페이지를 이동하거나 새로고침하면 전체 페이지를 다시 렌더링한다.\r\n\r\n### MPA의 장점\r\n\r\n1. **SEO 최적화**\r\n\r\n- MPA는 완성된 형태의 HTML 파일을 서버로부터 전달받는다. 이때 각 페이지가 독립적인 URL을 가지므로 검색 엔진이 페이지를 쉽게 색인화(Indexing)을 할 수 있다. 따라서 SEO(Search Engine Optimization)에 유리하다.\r\n\r\n2. **초기 로딩 속도가 빠르다.**\r\n   - 서버에서 그려진 HTML을 렌더링하기 때문이다.\r\n\r\n### MPA의 단점\r\n\r\n1. **새로운 페이지로 이동하면 '깜빡'이는 현상이 있다.**\r\n\r\n   - 페이지 요청마다 전체 페이지를 다시 렌더링(새로고침)을 한다.\r\n\r\n2. **페이지 이동 시 불필요한 템플릿도 중복해서 로딩**\r\n3. **서버 렌더링에 따른 부하**\r\n\r\n## SPA(Single Page Application)이란?\r\n\r\n- SPA는 말 그대로 한 개의 페이지로 구성된 애플리케이션을 말한다.\r\n- SPA는 보통 CSR(Client Side Rendering) 방식으로 렌더링한다.\r\n  - 그러나 SPA는 SSR이나 SSG와 같은 다른 렌더링 방식을 사용할 수도 있다.  \r\n    예를 들어, Next.js는 SPA를 구현하면서도 SSR이나 SSG를 지원한다.\r\n- 처음 페이지 로딩 시 웹 애플리케이션의 모든 정적 리소스(Html, Css, Javascript ...)를  \r\n  한 번에 다운받는다. 따라서 사용자가 처음 접속할 때 로딩 시간이 길 수 있다.\r\n- 최초 페이지를 로딩한 시점부터는 페이지 리로딩없이 필요한 부분만 서버로부터 받아서 화면을 갱신한다.(Ajax 덕분에 페이지를 다시 로드할 필요가 없다) 필요한 부분만 갱신하기 때문에 자연스러운 페이지 이동과 UX를 제공한다.\r\n\r\n### SPA의 장점\r\n\r\n1. **자연스러운 사용자 경험(UX)과 빠른 속도**\r\n\r\n   - 전체 페이지를 새로고침하지 않고 필요한 데이터만 바꾸므로 마치 네이티브 앱과 같이 빠르고 '깜빡' 거림이 없다.\r\n\r\n2. **네트워크 트래픽 감소**\r\n\r\n   - 서버에 전체 페이지를 요청하는 대신 필요한 데이터만 요청하므로 네트워크 트래픽이 감소한다.\r\n\r\n3. **백엔드 서버 부하 감소**\r\n\r\n### SPA의 단점\r\n\r\n1. **초기 로딩 시간(Code Splitting으로 해결 가능)**\r\n\r\n   - SPA는 처음 로딩할 때 애플리케이션의 전체를 로드해야 하므로 초기 로딩 시간이 길 수 있다.\r\n\r\n2. **SEO에 취약(SSR로 해결 가능)**\r\n   - 웹 크롤러가 Javascript를 완벽하게 해석하지 못하는 경우, 페이지의 내용이 제대로 색인화(Indexing)되지 않을 수 있다.\r\n\r\n## SSR vs CSR\r\n\r\n![](https://raw.githubusercontent.com/leedawnn/leedawnn.github.ioo/master/assets/ssr.png)\r\n\r\nSSR은 서버에서 페이지를 렌더링하는 방식이다. 사용자가 웹 페이지에 접속하면, 서버에서 해당 페이지를 렌더링하여 HTML 형태로 사용자에게 전송한다. 이 방식은 전통적인 웹 애플리케이션에서 주로 사용되었으나, 최근에는 React, Vue 등의 라이브러리나 프레임워크에도 SSR을 지원하고 있다.\r\n\r\n### SSR의 장점\r\n\r\n1. **초기 로딩 속도가 짧기 때문에 사용자가 빠르게 화면을 볼 수 있다.**\r\n2. **SEO에 효율적이다.**\r\n\r\n### SSR의 단점\r\n\r\n1. **페이지를 요청할 때마다 필요한 부분만 바꿔서 보여주는 것이 아니라 새로운 페이지를 보여주기 때문에 화면이 깜빡이는 현상이 있다.**\r\n2. **서버에 계속 요청을 해야하기 때문에 서버 부하가 커진다.**\r\n3. **동적으로 데이터를 처리하는 파일을 받아노는 것이 느리면, 사용자가 아무리 클릭을 해도 반응하지 않는 경우가 생기기도 한다.**\r\n\r\n![](https://raw.githubusercontent.com/leedawnn/leedawnn.github.ioo/master/assets/csr.png)\r\n\r\nCSR은 클라이언트 측에서 페이지를 렌더링하는 방식이다. 사용자가 웹 애플리케이션에 처음 접속하면, 서버로부터 필요한 모든 자바스크립트 파일을 다운로드 받는다. 이후 페이지의 렌더링은 클라이언트 측에서 이루어진다. 사용자의 상호작용에 따라 필요한 데이터만 서버로부터 가져와서 페이지르르 업데이트한다. 이 방식은 SPA에서 주로 사용된다.\r\n\r\n### CSR의 장점\r\n\r\n1. **사용자 경험이 좋고, 서버 부하가 적다.**\r\n2. **한 번의 로딩 후에는 서버로부터 새로운 페이지를 요청하지 않기 때문에 반응성이 좋다.**\r\n\r\n### CSR의 단점\r\n\r\n1. **초기 로딩 속도가 길다.**\r\n2. **SEO에 문제가 있을 수 있다. 웹 크롤러가 자바스크립트를 완벽하게 해석하지 못하는 경우, 페이지의 내용이 제대로 색인화되지 않을 수 있다.**\r\n"},{"excerpt":"","fields":{"slug":"/nextjs-rendering/"},"frontmatter":{"date":"March 05, 2024","title":"↗️ Next.js의 렌더링 방식 이해하기","tags":["nextjs","SSR","SSG","ISR"]},"rawMarkdownBody":"\r\n##\r\n"},{"excerpt":"순수 함수란 무엇인가? 순수 함수란 사이드 이펙트가 없는 함수, 즉 함수의 실행이 외부에 영향을 끼치지 않는 함수를 뜻하고 입력으로 전달된 값을 수정하지 않는 불변성을 가지고 있다. 따라서 순수함수는 어떠한 전달인자가 주어지더라도 항상 똑같은 값이 리턴됨을 보장한다. 사이드 이펙트를 만들지 않는다. 함수는 입력받은 값만을 가지고 결과를 반환하며, 그 외 …","fields":{"slug":"/pure-components/"},"frontmatter":{"date":"March 04, 2024","title":"🐳 React에서의 순수 컴포넌트","tags":["react","pure function","components"]},"rawMarkdownBody":"\r\n## 순수 함수란 무엇인가?\r\n\r\n순수 함수란 사이드 이펙트가 없는 함수, 즉 함수의 실행이 외부에 영향을 끼치지 않는 함수를 뜻하고 입력으로 전달된 값을 수정하지 않는 불변성을 가지고 있다. 따라서 순수함수는 어떠한 전달인자가 주어지더라도 항상 똑같은 값이 리턴됨을 보장한다.\r\n\r\n- **사이드 이펙트를 만들지 않는다.** 함수는 입력받은 값만을 가지고 결과를 반환하며, 그 외 어떤 외부 상태도 변경하지 않는다.\r\n- **동일 입력, 동일 출력.** 동일한 입력에 대해 순수 함수는 언제나 동일한 결과를 출력한다.\r\n\r\n### 사이드 이펙트란?\r\n\r\n함수의 입력 외에도 함수의 결과에 영향을 미치는 요인이다. 대표적으로 네트워크 요청,  \r\nAPI 호출이 side effect이다.\r\n\r\n### 순수 함수 개념이 중요한 이유는?\r\n\r\n사이드 이펙트를 줄이고, 모듈화 수준을 높이는 함수형 프로그래밍의 특징, 즉 순수 함수는 평가 시점이 무관하다는 특징으로 인해 효율적인 로직을 구성할 수 있다.\r\n\r\n## React에서의 순수 컴포넌트란?\r\n\r\nReact는 순수 함수를 중심으로 설계되었다. 모든 컴포넌트가 순수 함수라고 가정한다.  \r\n즉, 우리가 작성하는 React 컴포넌트는 동일한 입력이 주어졌을 때 항상 동일한 JSX를 반환해야 한다.\r\n\r\n다음 코드는 불순한 컴포넌트의 예시이다. 😒\r\n\r\n```js\r\nlet guest = 0\r\n\r\nfunction Cup() {\r\n  // Bad : 기존 변수를 변경합니다!\r\n  guest = guest + 1\r\n  return <h2>Tea cup for guest #{guest}</h2>\r\n}\r\n\r\nexport default function TeaSet() {\r\n  return (\r\n    <>\r\n      <Cup />\r\n      <Cup />\r\n      <Cup />\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n이 컴포넌트는 외부에서 선언된 `guest` 변수를 읽고 쓰고 있다. **즉, 이 컴포넌트는 호출할 때마다 다른 JSX가 생성된다는 뜻이다!** 게다가 다른 컴포넌트가 `guest`를 읽으면 렌더링된 시점에 따라 JSX도 다르게 생성된다.\r\n\r\n`guest`를 props로 전달함으로써 이 컴포넌트를 고칠 수 있다. 😊\r\n\r\n```js\r\nfunction Cup({ guest }) {\r\n  return <h2>Tea cup for guest #{guest}</h2>\r\n}\r\n\r\nexport default function TeaSet() {\r\n  return (\r\n    <>\r\n      <Cup guest={1} />\r\n      <Cup guest={2} />\r\n      <Cup guest={3} />\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n이제 컴포넌트가 반환하는 JSX는 `guest` props에만 의존하므로 순수하다. 각 컴포넌트는 렌더링 중에 다른 컴포넌트와 조율하거나 의존하지 말고 \"스스로 생각\"하게 해야한다.\r\n\r\n## local mutation (지역 변이) : 컴포넌트의 작은 비밀\r\n\r\n위의 예시에서는 컴포넌트가 렌더링하는 동안 기존 변수를 변경하는 것이 문제였다. 이를 \"**변이(mutation)**\" 이라고 부른다. 순수 함수는 함수의 범위를 벗어난 변수나 호출 전에 생성된 객체를 변이하지 않는다. 그러면 순수하지 않기 때문이다.\r\n\r\n하지만 **렌더링하는 동안 '방금' 생성한 변수와 객체를 변경하는 것은 괜찮다.** 이 예제에서는 배열을 생성하고 이를 `cups` 변수에 할당한 다음 컵 12개를 그 안에 push 한다.\r\n\r\n```js\r\nfunction Cup({ guest }) {\r\n  return <h2>Tea cup for guest #{guest}</h2>\r\n}\r\n\r\nexport default function TeaGathering() {\r\n  let cups = []\r\n  for (let i = 1; i < 12; i++) {\r\n    cups.push(<Cup key={i} guest={i} />)\r\n  }\r\n\r\n  return cups\r\n}\r\n```\r\n\r\n`cups` 변수나 배열이 `TeaGathering` 함수 외부에서 생성되었다면 이는 큰 문제가 될 것이다! 해당 배열에 항목을 밀어 넣음으로써 기존 객체를 변경하게 될 것이기 때문이다.\r\n\r\n하지만 `TeaGathering` 내부에서 동일한 렌더링 중에 생성했기 때문에 괜찮다. `TeaGathering` 외부의 어떤 코드도 이런 일이 일어났다는 것을 알 수 없다. 이를 \"**지역 변이(Local Mutation)**\"이라고 하며, 컴포넌트의 작은 비밀과 같다.\r\n\r\n## 사이드 이펙트를 일으킬 수 있는 곳\r\n\r\n함수형 프로그래밍은 순수성에 크게 의존하지만, 언젠가는 어딘가에서 무언가는 바뀌어야 한다. 이것이 바로 프로그래밍의 핵심이다! 화면 업데이트, 애니메이션 시작, 데이터 변경과 같은 이러한 변경을 **사이드 이펙트**라고 하며, 렌더링 중에 일어나는 것이 아니라 \"부수적으로\" 일어나는 일이다.\r\n\r\n**React에서 사이드 이펙트는 보통 이벤트 핸들러에 속한다.** 이벤트 핸들러가 컴포넌트 내부에 정의되어 있긴 하지만 렌더링 중에는 실행되지 않는다! **따라서 이벤트 핸들러는 순수할 필요가 없다.**\r\n\r\n다른 모든 옵션을 다 사용했는데도 사이드 이펙터에 적합한 이벤트 핸들러를 찾을 수 없다면, 컴포넌트에서 `useEffect` 호출을 통해 반환된 JSX에 이벤트 핸들러를 첨부할 수 있다. 이렇게 하면 나중에 렌더링 후 사이드 이펙트가 허용될 때 React가 이를 실행하도록 지시한다. **하지만 이 방법은 최후의 수단으로 사용해야한다.**\r\n\r\n## 요약\r\n\r\n- 컴포넌트는 순수해야 한다.\r\n  - **사이드 이펙트를 만들지 않는다.** 함수는 입력받은 값만을 가지고 결과를 반환하며, 그 외 어떤 외부 상태도 변경하지 않는다.\r\n  - **동일 입력, 동일 출력.** 동일한 입력에 대해 순수 함수는 언제나 동일한 결과를 출력한다.\r\n- 컴포넌트가 렌더링에 사용하는 어떠한 입력값도 변이해서는 안된다. 여기에는 props, state 및 context가 포함된다. 화면을 업데이트하려면 기존 객체를 변이하는 대신 `setState`를 사용하자.\r\n- 컴포넌트의 로직을 반환하는 JSX 안에 표현하기 위해 노력하자. \"무언가를 변경\"해야 할 때는 보통 이벤트 핸들러에서 이 작업을 수행하고자 할 것이다. 최후의 수단으로 `useEffect`를 사용할 수 있다.\r\n"},{"excerpt":"로그인을 구현할 때 어떤 방법이 있을까? 프론트엔드에서 로그인을 구현하는 방법에는 여러 가지가 있다. 세션 기반 인증 : 사용자가 로그인을 하면 서버는 사용자의 정보를 세션에 저장하고, 클라이언트에 세션 ID를 쿠키로 전송한다. 클라이언트는 이 쿠키를 보관하고 있다가 다음 요청 시 쿠키를 함께 보내 서버에서 인증을 받는다. 서버는 세션 ID를 통해 사용자…","fields":{"slug":"/login-logics/"},"frontmatter":{"date":"February 28, 2024","title":"🔧 로그인 로직 이해하기","tags":["login","jwt","session","cookie"]},"rawMarkdownBody":"\r\n## 로그인을 구현할 때 어떤 방법이 있을까?\r\n\r\n프론트엔드에서 로그인을 구현하는 방법에는 여러 가지가 있다.\r\n\r\n- **세션 기반 인증** : 사용자가 로그인을 하면 서버는 사용자의 정보를 세션에 저장하고, 클라이언트에 세션 ID를 쿠키로 전송한다. 클라이언트는 이 쿠키를 보관하고 있다가 다음 요청 시 쿠키를 함께 보내 서버에서 인증을 받는다. 서버는 세션 ID를 통해 사용자의 정보를 찾아 인증한다.\r\n- **토큰 기반 인증 (jwt ..)** : 사용자가 로그인을 하면 서버는 사용자의 정보를 토큰에 담아 클라이언트에게 전송한다. 클라이언트는 이 토큰을 보관하고 있다가 다음 요청 시 토큰을 함께 보내 서버에서 인증을 받는다. 서버는 토큰을 해독해 사용자의 정보를 확인하고 인증한다.\r\n- **OAuth** : 사용자가 이미 가입한 다른 서비스의 계정을 이용해 로그인하는 방법이다. 예를 들어, 구글이나 페이스북(meta) 계정으로 로그인하는 것이 이에 해당한다. 이 방식은 OAuh 프로토콜을 사용하며, 사용자가 서비스에 개인 정보를 제공하는 것 없이도 인증을 할 수 있다.\r\n- **Firebase Auth** : Firebase는 인증에 필요한 백엔드 서비스를 제공한다. 클라이언트 단에서 REST API를 사용하기만 하면 인증을 구현할 수 있다.\r\n\r\nOAuth와 같은 다른 서비스를 이용하여 인증을 구현하는 방식을 제외하고, JWT와 세션을 이용한 로그인 로직에 대해 알아보자.\r\n\r\n## JWT (JSON Web Token)\r\n\r\n- **구현 방법**\r\n  1. 사용자가 로그인에 성공하면 서버에서 JWT를 생성하여 사용자에게 반환한다.\r\n  2. 사용자는 이 JWT를 클라이언트 측에 저장하고, 이후 요청에 대해 HTTP 헤더에 포함시켜 인증한다.\r\n  3. 서버는 이 토큰을 디코딩하여 유효성을 검증하고 요청을 처리한다.\r\n- **장점**\r\n  - 서버 측에서 세션 상태를 유지할 필요가 없으므로 Stateless하고 확장성이 좋다.\r\n  - 또한, 토큰은 클라이언트 측에서 저장되므로 서버의 부하를 줄일 수 있다.\r\n- **단점**\r\n  - JWT는 상대적으로 크기가 크므로, 매 요청마다 토큰을 포함시켜 보내야 하기 때문에 네트워크 부하가 생길 수 있다.\r\n  - 또한, 한번 발급된 토큰은 유효기간이 만료될 때까지 계속 유효하므로 보안 문제가 발생할 수 있다.\r\n\r\n## 세션\r\n\r\n- **구현 방법**\r\n  1. 사용자가 로그인에 성공하면 서버에서 세션 ID를 생성하여 사용자에게 반환한다.\r\n  2. 이 세션 ID와 매칭되는 사용자 정보를 서버에 저장한다.\r\n  3. 사용자는 이후 요청에 대해 세션 ID를 포함시켜 서버에 전송하고, 서버는 이 세션 ID를 통해 사용자를 식별한다.\r\n- **장점**\r\n  - 사용자 정보는 서버에 저장되므로, 보안성이 상대적으로 높다.\r\n  - 서버에서 사용자의 상태 정보를 관리하므로 상세한 컨트롤이 가능하다.\r\n- **단점**\r\n  - 사용자가 많아질수록 서버의 메모리를 많이 차지하게 되므로 확장성에 문제가 생길 수 있다.\r\n  - 서버 기반의 인증 방식이므로 서버의 부하가 증가할 수 있다.\r\n"},{"excerpt":"컴포넌트를 분리하는 방법에는 어떤 것이 있을까? 컴포넌트를 분리하는 방법론들에 따라, 컴포넌트를 분리하는 \"기준\"이 달라지게 된다. 보통 컴포넌트를 분리하는 방법론은 아래와 같이 나뉜다. 컴포넌트의 관심사 분리(Separation of Concerns, SoC) headless 컴포넌트 SOLID, 단일 책임의 원칙 이 방법론들은 각각 어떤 기준을 가지고…","fields":{"slug":"/react-components/"},"frontmatter":{"date":"February 26, 2024","title":"🚀 React에서 컴포넌트를 분리하는 기준","tags":["react","components"]},"rawMarkdownBody":"\r\n## 컴포넌트를 분리하는 방법에는 어떤 것이 있을까?\r\n\r\n컴포넌트를 분리하는 방법론들에 따라, 컴포넌트를 분리하는 \"기준\"이 달라지게 된다.  \r\n보통 컴포넌트를 분리하는 방법론은 아래와 같이 나뉜다.\r\n\r\n1. **컴포넌트의 관심사 분리(Separation of Concerns, SoC)**\r\n2. **headless 컴포넌트**\r\n3. **SOLID, 단일 책임의 원칙**\r\n\r\n이 방법론들은 각각 어떤 기준을 가지고 있는지 하나씩 알아보자.\r\n\r\n## 컴포넌트의 관심사 분리(Separation of Concerns, SoC)\r\n\r\n### 관심사의 분리란?\r\n\r\n- 관심사의 분리란 복잡한 코드를 비슷한 기능을 하는 코드끼리 별도로 관리하는 것을 말한다.\r\n- 프로그램을 구별된 '개개의 관심사를 해결하는 부분'으로 분리하는 디자인 원칙이다.\r\n- 컴포넌트 별로 관심사를 분리하면 확장성과 재사용성을 높일 수 있다.\r\n\r\n### 컴포넌트를 분리하는 이유\r\n\r\n- 컴포넌트는 의도에 따라 **UI를 표현**하고자 하거나 **동작하는 로직**을 담을 수 있다.\r\n- 이처럼 컴포넌트는 재사용할 수 있는 최소 UI 단위임에도 불구하고, 웹의 복잡도와 해당 컴포넌트에서 수행하려고 하는 역할에 따라 얼마든지 복잡해질 수 있다.\r\n- 따라서 '관심사의 분리' 원칙에 따라 컴포넌트를 분리해서 관리하여야 한다.\r\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}