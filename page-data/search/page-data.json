{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"알고리즘을 풀면서 아래와 같은 함수를 작성하여, 값을 변경하고 두 수의 위치를 바꾸려고 했다. 하지만 의도와는 다르게 은 위치를 바꾸지 못하고 는 원본 그대로를 출력한다. 왜 함수 n1, n2의 값을 변경하지 못하는 걸까? 🥲 자바스크립트에서 기본 타입(primitive types)은 으로 함수에 전달되기 때문이다. 이는 함수에 값을 전달할 때, 실제 값…","fields":{"slug":"/js-type/"},"frontmatter":{"date":"March 21, 2024","title":"🙌 값에 의한 전달(Pass by Value)와 참조에 의한 전달(Pass by Reference) ","tags":["javascript","pass by value","pass by reference"]},"rawMarkdownBody":"\r\n알고리즘을 풀면서 아래와 같은 함수를 작성하여, 값을 변경하고 두 수의 위치를 바꾸려고 했다.\r\n\r\n```js\r\nfunction changeNum(n1, n2) {\r\n  if (n1 < n2) {\r\n    n1 = n2 + 1\r\n  } else {\r\n    n2 = n1 + 1\r\n  }\r\n}\r\n\r\nconst arr = [2, 3, 9]\r\nlet [a, b, c] = arr\r\n\r\nchangeNum(a, b)\r\n\r\nconsole.log(arr) // [2, 3, 9]\r\n```\r\n\r\n하지만 의도와는 다르게 `changeNum`은 위치를 바꾸지 못하고 `arr`는 원본 그대로를 출력한다.\r\n\r\n왜 함수 n1, n2의 값을 변경하지 못하는 걸까? 🥲\r\n\r\n자바스크립트에서 기본 타입(primitive types)은 `값에 의한 전달(Pass by Value) 방식`으로 함수에 전달되기 때문이다. 이는 **함수에 값을 전달할 때, 실제 값의 복사본이 전달되며, 함수 내에서 매개변수의 값을 변경해도 외부의 변수에는 영향을 미치지 않는다는 것을 의미**한다.\r\n\r\n따라서 changeNum 함수 내에서 n1, n2의 값을 변경해도 a, b 원본에는 영향을 주지 않는다.\r\n\r\n그럼 어떻게 바꿀 수 있을까?\r\n\r\n## 참조에 의한 전달(Pass by Reference)\r\n\r\n객체나 배열과 같은 참조 타입은 `참조에 의한 전달(Pass by Reference)` 방식으로 작동한다. 이 방식에서는 **변수가 실제 데이터가 아닌, 데이터가 저장된 메모리 주소를 참조**한다.\r\n\r\n함수에 참조 타입의 값을 인자로 전달할 때, 전달 되는 것은 실제 데이터의 복사본이 아니라 데이터가 저장된 메모리 주소의 참조이다. **따라서 함수 내에서 참조를 통해 데이터를 변경하면 원본 데이터에도 반영이 된다.**\r\n\r\n이러한 방식을 이용하여 n1과 n2 값을 변경하면 객체나 배열을 통해 값을 전달하고, 함수 내에서 객체의 속성이나 배열의 요소를 변경할 수 있다.\r\n\r\n```js\r\nfunction changeNum(arr) {\r\n  if (arr[0] < arr[1]) {\r\n    arr[0] = arr[1] + 1\r\n  } else {\r\n    arr[1] = arr[0] + 1\r\n  }\r\n}\r\n\r\nconst arr = [2, 3, 9]\r\nchangeNum(arr)\r\n\r\nconsole.log(arr) // [4, 3, 9]\r\n```\r\n\r\n## 값에 의한 전달(Pass by Value)\r\n\r\n아까 말했듯이 기본 타입(primitive type)인 숫자, 문자열, boolean, null, undefined, Symbol, BigInt은 `값에 의한 전달(Pass by Value)`방식으로 처리한다. 이는 **함수에 기본 타입의 값을 인자로 전달할 때, 실제 값이 아닌 그 값의 복사본이 함수 내부로 전달된다는 의미**이다.\r\n\r\n**따라서, 함수 내에서 매개변수의 값을 변경해도 원본 변수의 값에는 영향을 미치지 않는다.**\r\n\r\n아래는 값에 의한 전달에 대한 간단한 예시 코드다.\r\n\r\n```js\r\nfunction modifyValue(x) {\r\n  x = 5\r\n  console.log(\"함수 내부: \", x) // 함수 내부: 5\r\n}\r\n\r\nlet a = 3\r\n\r\nmodifyValue(a)\r\nconsole.log(\"함수 외부: \", a) // 함수 외부: 3\r\n```\r\n\r\n## 요약\r\n\r\n- 자바스크립트에서 **기본 타입(primitive type)**은 `값에 의한 전달(Pass by Value)` 방식으로 처리된다. 즉, 함수 내에서 매개변수의 값을 변경해도 원본 변수의 값에는 영향을 미치지 않는다.\r\n- 반면 객체나 배열 같은 **참조 타입(reference type)**은 `참조에 의한 전달(Pass by Reference)` 방식으로 처리된다.\r\n"},{"excerpt":"디자인 패턴이란? 본론에 들어가기 앞서, 디자인 패턴의 정의와 사용하는 이유에 대해 알아보자. 디자인 패턴이란 개발 과정에서 공통으로 발생하는 문제를 해결하기 위해 사용되는 패턴이다. 저명한 소프트웨어 엔지니어 마틴 파울러는 디자인 패턴을 '절반만 완성된' 것이라고 표현한다. 디자인 패턴은 코드로 구현된 구현체가 아니라 문제 해결을 위한 패턴이기 때문에 …","fields":{"slug":"/design-patterns/"},"frontmatter":{"date":"March 21, 2024","title":"✨ 프론트엔드에서 사용하는 디자인 패턴에는 뭐가 있을까?","tags":["design-pattern","architecture"]},"rawMarkdownBody":"\r\n## 디자인 패턴이란?\r\n\r\n본론에 들어가기 앞서, 디자인 패턴의 정의와 사용하는 이유에 대해 알아보자.\r\n\r\n**디자인 패턴**이란 개발 과정에서 공통으로 발생하는 문제를 해결하기 위해 사용되는 패턴이다. 저명한 소프트웨어 엔지니어 *마틴 파울러*는 디자인 패턴을 '절반만 완성된' 것이라고 표현한다. 디자인 패턴은 코드로 구현된 구현체가 아니라 문제 해결을 위한 패턴이기 때문에 자신의 개발 환경에 맞게 구현하는 것은 개발자의 몫이기 때문이다.\r\n\r\n### 무조건 디자인 패턴을 활용하는 것이 좋은걸까?\r\n\r\n우리는 간단한 TODO 앱을 만들 때 디자인 패턴이 필요하다고 말하지 않는다. 대부분의 디자인 패턴은 복잡하고 거대한 프로그램을 위해서 만들어졌다.\r\n\r\n## 그래서, 디자인 패턴을 사용하는 이유가 뭘까?\r\n\r\n- **증명된 솔루션이다.**\r\n\r\n디자인 패턴은 최고의 개발자들이 만들어 낸 솔루션이다. 또한, 오랜 기간 사용되어 오면서 안정성 검증이 완료된 솔루션이다. 심지어 디자인 패턴은 문서화도 잘 되어있다. 거인의 어깨에 올라타서 안정적인 프로그램을 만들 수 있다.\r\n\r\n- **재사용성과 유지보수성**\r\n\r\n디자인 패턴은 검증된 해결 방법을 제공함으로써 개발 과정에서 비슷한 문제가 재발할 때마다 이를 재사용할 수 있게 한다. 이는 개발 시간을 단축시키고, 코드의 품질을 높일 수 있다. 또한 소프트웨어의 구조를 명확하게 하고, 코드의 가독성을 높여준다. 이로 인해 다른 개발자들이 코드를 이해하고 유지보수하기가 더 쉬워진다.\r\n\r\n- **확장성**\r\n\r\n디자인 패턴을 사용함으로써 시스템의 일부분을 변경하거나 확장하는 것이 더 용이해진다. 패턴은 일반적으로 유연성을 고려하여 설계되므로, 시스템을 쉽게 확장하거나 수정할 수 있다.\r\n\r\n## 프론트엔드에서의 디자인 패턴 활용\r\n\r\n프론트엔드에서는 다양한 디자인 패턴이 활용된다. 그 중에서도 특히 SPA(Single Page Application) 프레임워크나 라이브러리들이 `MVC`, `MVVM`과 같은 패턴을 채택하거나 변형하여 사용한다.\r\n\r\n예를 들어,\r\n\r\n- **React** : React 자체는 라이브러리이기 때문에 엄밀히 말해 디자인 패턴을 강제하지는 않는다. 그러나, `Flux 아키텍처`나 `Redux`와 같은 상태 관리 라이브러리와 함께 사용되어 일종의 `MVC` 변형 패턴으로 볼 수 있다.\r\n- **Angular** : `MVVM`나 `MVC` 패턴의 변형을 사용한다. Angular는 데이터 바인딩, 의존성 주입 등의 기능을 통해 개발자가 이 패턴을 더 쉽게 구현할 수 있도록 돕는다.\r\n- **Vue** : `MVVM` 패턴에 가깝다. Vue는 `ViewModel`의 역할을 하는 Vue 인스턴스를 통해 `View`와 `Model`을 연결한다.\r\n\r\n이제 어떤 디자인 패턴들이 있는지 자세히 알아보자.\r\n\r\n## MVC (Model-View-Controller)\r\n\r\n![](https://www.freecodecamp.org/news/content/images/2021/04/MVC3.png)\r\n\r\n- **Model** : 데이터와 비즈니스 로직을 관리한다. 데이터 조회나 저장과 같은 기능을 수행하며, 데이터의 상태 변화를 `View`와 `Controller`에 통지한다.\r\n- **View** : 사용자 인터페이스(UI)를 담당한다. 사용자에게 정보를 표시하고, 사용자의 입력을 받는다.\r\n- **Controller** : 사용자의 입력을 받아 `Model`을 업데이트하고, 그 결과를 `View`에 반영한다. `View`와 `Model` 사이의 중재자 역할을 한다. 비즈니스 로직을 처리하는 `Model`과 완전히 UI에 의존적인 `View`가 서로 직접 이야기할 수 없게 한다.\r\n\r\n### `MVC`의 한계\r\n\r\n`MVC`에서 `View`는 `Controller`에 연결되어 화면을 구성하는 단위요소이므로 다수의 `View`들을 가질 수 있다. 그리고 `Model`은 `Controller`를 통해 `View`와 연결되어지지만, `Controller`를 통해서 하나의 `View`에 연결될 수 있는 `Model`도 여러 개가 될 수 있다.\r\n\r\n이렇게 되면 `View`와 `Model`이 서로 의존성을 띄게 된다.\r\n\r\n화면에 복잡한 화면과 데이터의 구성이 필요하다면, `Controller`에 다수의 `Model`과 `View`가 복잡하게 연결되어 있는 상황이 생길 수 있다.\r\n\r\n**따라서, View에서 데이터 업데이트를 할 때 연쇄적인 업데이트가 일어나게 되고 앱이 커지면 업데이트 흐름을 따라가기 힘들어진다.**\r\n\r\n`MVC`가 너무 복잡하고 비대해져서 새 기능을 추가할 때마다 크고 작은 문제점을 가지는 형태를 `Massive ViewController(대규모 MVC 어플리케이션)`라고 부른다. `MVC`의 한계를 잘 나타내는 용어이다.\r\n\r\n이후 이러한 문제점을 보완한 여러 다양한 패턴들이 파생되었다. `MVP`, `MVVM`, `Flux` 등...\r\n\r\n## MVVM (Model-View-ViewModel)\r\n\r\n![](https://miro.medium.com/v2/resize:fit:720/format:webp/1*J7_36YMEO8pNAYGyR53hkA.png)\r\n\r\n- **Model** : MVC 패턴의 Model과 동일하게 데이터와 비즈니스 로직을 관리한다.\r\n- **View** : 사용자에게 보여지는 UI 부분을 담당한다. `View`는 `ViewModel`을 통해 사용자의 입력을 처리하고, 상태 변화를 표시한다.\r\n- **ViewModel** : `View`를 표현하기 위한 데이터와 명령을 가지고 있다. `ViewModel`의 역할은 `View`가 사용할 메서드와 필드를 구현하고, `View`에게 상태 변화를 알리는 것이다. `View`와 `Model` 사이의 의존성을 줄인다.\r\n\r\n`MVVM`을 구성하는 3가지 요소의 역할과 책임을 이해하기 위해서는 먼저 이들 사이의 관계를 알아야합니다. `View`는 `ViewModel`을 알지만, `ViewModel`은 `View`를 알지 못합니다. 또한, `ViewModel`은 `Model`을 알지만, `Model`은 `ViewModel`을 알지 못한다.\r\n\r\n이런 구조를 통해서 `ViewModel`과 `Model`이 `View`로부터 독립적인 형태를 만들어서 위에서 말한 UI로부터 비즈니스 로직과 프레젠테이션 로직을 분리라는 목적을 이룰 수 있게 되었다.\r\n\r\n### `MVVM`의 한계\r\n\r\n하지만 `MVVM` 패턴은 거대하고 복잡한 애플리케이션을 위해서 고안된 디자인 패턴인 만큼, 작은 규모의 애플리케이션에서 사용하게 되면 오버헤드가 커진다. 또한 데이터 바인딩이 복잡해지면 성능 저하 또는 디버깅이 어렵다는 단점이 있다.\r\n\r\n## Flux 아키텍처\r\n\r\n![](https://fullstackopen.com/static/7bf90479b6757c7af3b9a9f0e7f19a64/5a190/flux2.png)\r\n\r\n> **🤔 디자인 패턴과 아키텍처는 다른 거 아냐?**\r\n>\r\n> Flux와 같은 **아키텍처**는 시스템의 전반적인 설계와 구조를 다루는 반면, 디자인 패턴은 그보다 더 세부적인 수준에서 구체적인 문제 해결 방법을 제공한다. 두 개념은 서로 보완적으로 작용할 수 있으며, 강력하고 유지보수가 용이한 소프트웨어를 개발하는 데 함께 사용될 수 있다.\r\n\r\n`Flux`는 Meta에서 개발한 애플리케이션 아키텍처로, 주로 React와 함께 사용된다. `Flux`의 핵심은 데이터의 \"**단방향 흐름**\"이다. 이는 애플리케이션의 예측 가능성을 높이고 디버깅을 용이하게 한다.\r\n\r\n`Flux` 아키텍처는 크게 4가지 구성 요소로 이루어져 있다.\r\n\r\n- **Action** : 사용자의 행동이나 시스템에서 발생하는 이벤트로부터 시작되는 데이터의 흐름이다. `Action`은 어떤 변화가 일어나야할 지를 설명한다.\r\n- **Dispatcher** : 모든 데이터 흐름의 중앙 허브이다. `Action`이 발생하면 `Dispatcher`를 통해 `Store`에 전달된다.\r\n- **Store** : 애플리케이션의 상태를 보유하고 있으며, `Dispatcher`로 부터 `Action`을 받아 상태를 업데이트한다.\r\n- **View** : 사용자에게 정보를 표시하고, 사용자의 상호작용을 받는다. `View`는 `Store`의 상태 변화에 반응하여 UI를 업데이트한다.\r\n\r\n`Flux` 아키텍처와 React의 조합은 다음과 같은 장점을 제공한다.\r\n\r\n- **명확한 데이터 흐름**\r\n\r\n`Flux`에서는 데이터가 단방향으로 흐르기 때문에 애플리케이션에서 데이터가 어떻게 이동하고 변하는지 추적하기가 훨씬 용이하다. 이러한 접근 방식은 디버깅을 간소화하고, 데이터 흐름 관련 버그를 줄여준다.\r\n\r\n- **컴포넌트와의 일관성**\r\n  Flux는 애플리케이션의 상태를 스토어에서 중앙 집중적으로 관리한다. 이로 인해 컴포넌트가 상태를 직접 관리하는 대신, `Store`를 통해 상태를 조회하고, `Action`을 통해 상태를 업데이트합니다. 이러한 접근은 컴포넌트를 상태로부터 분리시켜, 더욱 순수한 UI 컴포넌트를 만들 수 있게 해준다. 결과적으로, 컴포넌트의 재사용성과 테스트 용이성이 향상.\r\n\r\n- **유지보수의 용이성**\r\n\r\nFlux의 명확한 구조와 규칙은 큰 규모의 애플리케이션에서도 유지보수성을 향상시킨다. 코드의 구조가 명확하고, 각 부분의 역할이 분명하기 때문에 새로운 개발자가 프로젝트에 참여하거나 기존 코드를 수정하는 일이 훨씬 쉬워진다.\r\n\r\n- **확장성**\r\n  Flux 아키텍처는 애플리케이션의 확장을 용이하게 한다. 새로운 기능이나 데이터 흐름을 추가할 때 기존 시스템을 크게 변경하지 않고도, 애플리케이션의 구조 안에서 자연스럽게 확장할 수 있다.\r\n\r\n### `Flux`의 한계\r\n\r\n- **복잡성 증가**\r\n  Flux는 단방향 데이터 흐름을 제공하지만, 크고 복잡한 애플리케이션에서는 관리해야 할 액션, 디스패처, 스토어가 많아져 관리가 복잡해질 수 있습니다. 이는 프로젝트의 크기가 커질수록 더욱 두드러집니다.\r\n- **보일러플레이트 코드**\r\n  Flux 구현 시, 액션 타입, 액션 크리에이터, 스토어, 디스패처 등을 정의해야 합니다. 이 과정에서 반복적이고 유사한 코드가 많이 생성될 수 있으며, 이는 코드베이스를 불필요하게 늘릴 수 있습니다.\r\n- **유연성의 제한**\r\n  Flux 아키텍처는 엄격한 구조를 가지고 있으며, 이는 때때로 특정 상황에 대한 유연한 대응을 어렵게 만들 수 있습니다.\r\n"},{"excerpt":"Ajax (Asynchronous Javascript and XML) Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있다. 즉 Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹페이지의 일부분만 표시 할 수 있다. 동작 방식 Ajax는  객체를 사용하여 서버와 통신한다. 이 객체를 통해 데이터를 …","fields":{"slug":"/ajax-axios/"},"frontmatter":{"date":"March 13, 2024","title":"🦚 Ajax와 fetch, Axios는 어떻게 다를까?","tags":["ajax","fetch","axios"]},"rawMarkdownBody":"\r\n## Ajax (Asynchronous Javascript and XML)\r\n\r\nAjax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있다. 즉 Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹페이지의 일부분만 표시 할 수 있다.\r\n\r\n### 동작 방식\r\n\r\nAjax는 `XMLHttpRequest` 객체를 사용하여 서버와 통신한다. 이 객체를 통해 데이터를 비동기적으로 교환할 수 있으며, 페이지 전체를 새로고침하지 않고도 일부분만을 업데이트할 수 있다.\r\n\r\n### 사용법\r\n\r\n```js\r\nconst xhr = new XMLHttpRequest() // XMLHttpRequest 객체 생성\r\n\r\nxhr.open(\"GET\", \"url-to-the-server\", true) // 요청 초기화 (HTTP 요청 메서드, 요청을 보낼 서버의 url, 비동기적으로 요청할 것인지 boolean)\r\n// 응답 처리 이벤트 핸들러 (xhr.readyState === 4는 요청 완료되었음을 나타냄)\r\nxhr.onreadystatechage = function () {\r\n  if (xhr.readyState === 4 && xhr.status === 200) {\r\n    console.log(xhr.responseText) // 서버로부터 받은 데이터 처리\r\n  }\r\n}\r\n\r\nxhr.send() // 요청 전송\r\n```\r\n\r\n### 한계\r\n\r\nAjax는 `XMLHttpRequest` 객체를 사용하여 비동기 통신을 구현한다. 하지만 사용법이 복잡하고, 콜백 지옥(callback hell)과 같은 문제가 발생할 수 있다. 또한 JSON 데이터를 처리하기 위한 추가적인 변환 작업이 필요하다.\r\n\r\n### Fetch의 등장 배경\r\n\r\nFetch API는 `Promise`를 기반으로 하여 비동기 통신을 더욱 간결하고 직관적으로 만들 수 있게 해준다. Fetch는 `XMLHttpRequest`보다 더 유연하고 강력한 기능을 제공하며, 직접적으로 JSON을 지원하여 데이터 처리가 훨씬 간편해졌다.\r\n\r\n## Fetch API\r\n\r\nFetch API는 브라우저의 `window` 객체에 내장되어 있으며, `Request`와 `Response` 객체를 사용하여 요청과 응답을 쉽게 처리할 수 있다.\r\n\r\n### 사용법\r\n\r\n```js\r\nfetch(url, options)\r\n  .then(response => console.log(\"response: \", response.json())) // JSON 데이터로 변환\r\n  .catch(error => console.log(\"error: \", error))\r\n```\r\n\r\nfetch는 첫번째 인자로 `url`, 두번째 인자로 `옵션 객체`를 받고, `Promise` 타입의 객체를 반환한다. 반환된 객체는 API 호출이 성공했을 경우에는 응답(response) 객체를 `resolve`하고, 실패했을 경우에는 예외(error) 객체를 `reject`한다.\r\n\r\n### 한계\r\n\r\nFetch API는 많은 개선점을 제공하지만, 여전히 몇 가지 한계가 있다.  \r\n예를 들어, Fetch는 요청 시간 초과(timeouts)를 직접적으로 지원하지 않는다. 또한 브라우저 호환성 문제와 일부 기능(진행 상태 추적 등)에 대한 제한이 있을 수 있다.\r\n\r\n### Axios의 등장 배경\r\n\r\nAxios는 Fetch의 모든 장점을 가지면서도, Fetch의 한계를 극복하기 위해 등장했다. Axios는 요청 시간 초과 설정, 요청 취소, HTTP 상태 코드에 따른 자동 변환, 진행 상태 추적 등 추가적인 기능을 제공한다. 또한 브라우저뿐만 아니라 Node.js 환경에서도 사용할 수 있어서 서버 사이드와 클라이언트 사이드 모두 사용된다.\r\n\r\n## Axios\r\n\r\nAxios는 HTTP 요청을 보내기 위한 자바스크립트 라이브러리이다. Axios는 내부적으로 `XMLHttpRequest`를 사용하지만, `Promise` 기반의 API를 제공하여 보다 쉬운 비동기 처리를 가능하게 한다. 또한, 요청과 응답을 JSON 형태로 자동 변환해주거나 에러 처리 등과 추가적인 기능을 제공한다. 보통 아래와 같이 `async/await`와 함께 사용한다.\r\n\r\nFetch API와 비교했을 때 차이점을 좀 더 자세히 알아보자면, 아래와 같다.\r\n\r\n- **자동 JSON 변환**\r\n\r\n  Axios는 `response`를 자동으로 JSON 형태로 변환해준다. 반면, Fetch API는 `response`가 도착했을 때, `.json()`을 호출하여 수동으로 변환해야한다.\r\n\r\n- **에러 처리**\r\n\r\n  Fetch API는 네트워크 오류가 발생하지 않는 한 요청 실패를 액션이 실패로 간주하지 않는다. 즉, 404나 500 같은 서버 에러 상태에서도 `.then()`을 실행한다. 반면, Axios는 2xx 범위 외의 HTTP 상태 코드를 받으면 자동으로 에러를 발생시킨다.\r\n\r\n- **브라우저 지원**\r\n\r\n  Fetch API는 일부 구형 브라우저에서는 기본적으로 지원되지 않을 수 있다. 반면, Axios는 모든 브라우저에서 작동하도록 Promise API를 사용한다.\r\n\r\n- **timeout 설정**\r\n\r\n  Axios는 요청 타임아웃을 설정하는 옵션이 내장되어 있다. Fetch API에서는 이를 직접 구현해야한다.\r\n\r\n### 사용법\r\n\r\n```js\r\nconst fetchData = async () => {\r\n  try {\r\n    const response = await axios.get(\"url-to-the-server\")\r\n    console.log(response.data)\r\n  } catch (error) {\r\n    console.error(\"Error! : \", error)\r\n  }\r\n}\r\n```\r\n\r\n더 자세한 사용법을 알고싶다면, [**⚠️ 자바스크립트의 예외 처리**](https://leedawnn.github.io/error-handling/) 글을 참고!\r\n"},{"excerpt":"자바스크립트에서 에러가 발생하면 스크립트는 죽고, 콘솔에 에러가 출력된다. 그러나 문을 사용하면 스크립트가 죽는 걸 방지하고, 에러를 잡아서(catch) 예외 처리를 할 수 있게 된다. try...catch문 try...catch문의 동작은 다음과 같다. 먼저,  안의 코드가 실행된다. 에러가 없다면,  안의 마지막 줄까지 실행되고,  블록은 건너뛴다. …","fields":{"slug":"/error-handling/"},"frontmatter":{"date":"March 07, 2024","title":"⚠️ 자바스크립트의 예외 처리","tags":["javascript","try~catch","async","await"]},"rawMarkdownBody":"\r\n자바스크립트에서 에러가 발생하면 스크립트는 죽고, 콘솔에 에러가 출력된다.  \r\n그러나 `try...catch`문을 사용하면 스크립트가 죽는 걸 방지하고, 에러를 잡아서(catch) 예외 처리를 할 수 있게 된다.\r\n\r\n## try...catch문\r\n\r\n```js\r\ntry {\r\n  // ...\r\n} catch (error) {\r\n  // 에러 핸들링\r\n}\r\n```\r\n\r\n**try...catch문의 동작은 다음과 같다.**\r\n\r\n1. 먼저, `try {...}` 안의 코드가 실행된다.\r\n2. 에러가 없다면, `try` 안의 마지막 줄까지 실행되고, `catch` 블록은 건너뛴다.\r\n3. 에러가 있다면, `try` 안 코드의 실행이 중단되고, `catch(error)` 블록으로 제어 흐름이 넘어간다. 변수 error는 무슨 일이 일어났는지에 대한 설명이 담긴 에러 객체를 포함한다.\r\n\r\n`try {...}` 블록 안에서 에러가 발생해도 `catch`에서 에러를 처리하기 때문에 스크립트는 죽지 않는다.\r\n\r\n### `try...catch`는 오직 런타임 에러에만 동작한다.\r\n\r\n`try...catch`는 실행 가능한(runnable) 코드에만 동작한다. 실행 가능한 코드는 문법적으로 맞는 자바스크립트 코드를 의미한다.  \r\n자바스크립트 엔진은 코드를 읽고 난 후 코드를 실행한다. 코드를 읽는 중에 발생하는 에러는 'parse-time 에러'라고 부르는데, 엔진은 이 코드를 이해할 수 없기 때문에 parse-time 에러는 코드 안에서 복구가 불가능하다.\r\n\r\n`try...catch`는 유효한 코드에서 발생하는 에러만 처리할 수 있다. 이런 에러를 '런타임 에러(runtime error)' 혹은 '예외(exception)'라고 부른다.\r\n\r\n### `try...catch`문은 동기적으로 동작한다.\r\n\r\n`setTimeout`처럼 스케줄 된 코드에서 발생한 예외는 `try...catch`문에서 잡아낼 수 없다.\r\n\r\n```js\r\ntry {\r\n  setTimeout(function () {\r\n    noSuchVariable // 스크립트는 여기서 죽는다.\r\n  }, 1000)\r\n} catch (e) {\r\n  alert(\"작동 멈춤\")\r\n}\r\n```\r\n\r\n`setTimeout`에 넘겨진 익명 함수는 `try...catch`를 떠난 다음에서야 실행되기 때문이다.  \r\n스케줄 된 함수 내부의 예외를 잡으려면, `try...catch`를 반드시 함수 내부에 구현해야한다.\r\n\r\n```js\r\nsetTimeout(function () {\r\n  try {\r\n    noSuchVariable // 이제 try...catch에서 에러를 핸들링 할 수 있다!\r\n  } catch {\r\n    alert(\"에러를 잡았습니다!\")\r\n  }\r\n}, 1000)\r\n```\r\n\r\n### 에러 객체\r\n\r\n에러가 발생하면 자바스크립트는 에러 상세내용이 담긴 객체를 생성한다. 그 후, `catch` 블록에 이 객체를 인수로 전달한다.\r\n\r\n```js\r\ntry {\r\n  // ...\r\n} catch (e) {\r\n  // <-- 에러 객체\r\n  // ...\r\n}\r\n```\r\n\r\n내장 에러 전체와 에러 객체는 두 가지 주요 프로퍼티를 가진다.\r\n\r\n- `name`\r\n  에러 이름. 정의 되지 않은 변수 때문에 발생한 에러라면 `\"ReferenceError\"`가 이름이 된다.\r\n- `message`\r\n  에러 상세 내용을 담고 있는 문자 메시지.\r\n\r\n예시:\r\n\r\n```js\r\ntry {\r\n  lalala // 에러, 변수가 정의되지 않음!\r\n} catch (e) {\r\n  alert(e.name) // ReferenceError\r\n  alert(e.message) // lalala is not defined\r\n\r\n  // 에러 전체를 보여줄 수도 있다.\r\n  // 이때, 에러 객체는 \"name: message\" 형태의 문자열로 변환된다.\r\n  alert(e) // ReferenceError: lalala is not defined\r\n}\r\n```\r\n\r\n### `throw` 연산자\r\n\r\n`throw`문의 주요 용도는 크게 두 가지가 있다.\r\n\r\n1. 커스텀 에러 메시지\r\n   throw문을 사용하면 특정 조건에서 커스텀 에러 메시지를 생성할 수 있다. 이는 코드를 디버깅하는데 도움이 된다.  \r\n   또한, 특정 조건에서 발생하는 에러를 사용자에게 더 친절하게 전달할 수 있게 해준다.\r\n\r\n```js\r\nif (!isValid) {\r\n  throw new Error(\"입력 값이 유효하지 않습니다.\")\r\n}\r\n```\r\n\r\n2. 예외를 강제로 발생시키기\r\n   코드의 실행을 강제로 중단하고, 해당 에러를 `catch` 블록으로 전달할 수 있다. 이는 특정 조건에서 프로그램의 실행을 중단하고, 이를 적절하게 처리하고 싶을 때 유용하다.\r\n\r\n### 에러 다시 던지기\r\n\r\n```js\r\nlet json = '{ \"age\": 30 }' // 불완전한 데이터\r\n\r\ntry {\r\n  user = JSON.parse(json) // user 앞에 let을 붙이는 걸 잊음\r\n\r\n  // ...\r\n} catch (e) {\r\n  alert(\"JSON Error: \" + e) // JSON Error: ReferenceError: user is not defined\r\n  // 실제로는 JSON Error가 아님\r\n}\r\n```\r\n\r\n위 코드에서 '불완전한 데이터'를 다루려는 목적으로 `try...catch`를 사용했다. 그런데 catch는 원래 try 블록에서 발생한 모든 에러를 잡으려는 목적으로 만들어졌다. 그런데 위 예시에서 catch는 예상치 못한 에러를 잡아주긴 했지만, 에러 종류와 상관없이 `\"JSON Error\"` 메시지를 보여준다. 이렇게 에러 종류와 관계없이 동일한 방식으로 에러를 처리하는 것은 디버깅을 어렵게 만들기 때문에 좋지 않다.\r\n\r\n이런 문제를 피하고자 '**다시 던지기(rethrowing)**' 기술을 사용한다. 규칙은 간단하다.\r\n\r\n**catch는 알고 있는 에러만 처리하고 나머지는 '다시 던져야'한다.**\r\n\r\n1. catch가 모든 에러를 받는다.\r\n2. catch(e) {...} 블록 안에서 에러 객체 e를 분석한다.\r\n3. 에러 처리 방법을 알지 못하면 throw e를 한다.\r\n\r\n보통 에러 타입을 `instanceof` 명령어로 체크한다.\r\n\r\n```js\r\ntry {\r\n  user = {\r\n    /*...*/\r\n  }\r\n} catch (e) {\r\n  if (e instanceof ReferenceError) {\r\n    alert(\"ReferenceError\") // 정의되지 않은 변수에 접근하여 'ReferenceError' 발생\r\n  }\r\n}\r\n```\r\n\r\n## async와 await\r\n\r\nasync와 await를 사용하면 Promise를 좀 더 편하게 사용할 수 있다.\r\n\r\n### async 함수\r\n\r\n```js\r\nasync function f() {\r\n  return 1\r\n}\r\n```\r\n\r\n`async`는 function 앞에 위치한다.\r\n\r\nfunction 앞에 `async`를 붙이면 해당 함수는 항상 Promise를 반환한다. Promise가 아닌 값을 반환하더라도 이행(resolved) 상태의 Promise로 값을 감싸 이행된 Promise가 반환되도록 한다.\r\n\r\n```js\r\nasync function f() {\r\n  return 1\r\n}\r\n\r\nf().then(alert) // 1\r\n```\r\n\r\n`async`가 붙은 함수는 반드시 Promise를 반환하고, Promise가 아닌 것은 Promise로 감싸 반환한다. 또다른 키워드 `await`는 `async` 함수 안에서만 동작한다.\r\n\r\n### await\r\n\r\n```js\r\n// await는 async 함수 안에서만 동작한다.\r\nlet value = await promise\r\n```\r\n\r\n자바스크립트는 `await` 키워드를 만나면 Promise가 처리될 때까지 기다린다. 결과는 그 이후 반환된다.\r\n\r\n1초 후 이행되는 Promise를 예시로 `await`가 어떻게 동작하는지 살펴보자.\r\n\r\n```js\r\nasync function f() {\r\n  let promise = new Promise((resolve, reject) => {\r\n    setTimeout(() => resolve(\"완료!\"), 1000)\r\n  })\r\n\r\n  let result = await promise // Promise가 이행될 때까지 기다림\r\n\r\n  alert(result) // 완료!\r\n}\r\n```\r\n\r\n함수를 호출하고, 함수 본문이 실행되는 도중에 `await` 키워드를 만나면 실행이 잠시 중단되었다가 Promise가 처리되면 실행이 재개된다. 이때 Promise 객체의 result 값이 변수 result에 할당된다. 따라서 위 예시를 실행하면 1초 뒤에 `\"완료!\"`가 출력된다.\r\n\r\n`await`는 말 그대로 Promise가 처리될 때까지 함수 실행을 기다리게 만든다. Promise가 처리되면 그 결과와 함께 실행이 재개된다. Promise가 처리되길 기다리는 동안엔 엔진이 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있기 때문에, CPU 리소스가 낭비되지 않는다.\r\n\r\n`await`는 `promise.then`보다 더 세련되게 Promise의 result값을 얻을 수 있도록 하는 문법이다.\r\n`promise.then`보다 가독성이 좋고 사용하기도 쉽다.\r\n\r\n### 에러 핸들링\r\n\r\nPromise가 정상적으로 이행되면 `await promise`는 Promise 객체의 result에 저장된 값을 반환한다. 반면 Promise가 거부되면 마치 throw문을 작성한 것처럼 에러가 던져진다.\r\n\r\n```js\r\nasync function f() {\r\n  await Promise.reject(new Error(\"에러 발생!\"))\r\n}\r\n\r\n// 위 코드는 아래 코드와 동일하다.\r\nasync function f() {\r\n  throw new Error(\"에러 발생!\")\r\n}\r\n```\r\n\r\n실제 상황에선 Promise가 거부 되기 전에 약간의 시간이 지체되는 경우가 있다. 이런 경우엔 `await`가 에러를 던지기 전에 지연이 발생한다.\r\n\r\nawait가 던진 에러는 throw가 던진 에러를 잡을 때처럼 `try...catch`를 사용해 잡을 수 있다.\r\n\r\n```js\r\nasync function f() {\r\n  try {\r\n    let response = await fetch(\"http://유효하지-않은-주소\")\r\n  } catch (e) {\r\n    alert(e) // TypeError: failed to fetch\r\n  }\r\n}\r\n\r\nf()\r\n```\r\n\r\n`try...catch`가 없으면 아래 예시의 async 함수 `f()`를 호출해 만든 Promise가 거부 상태가 된다. `f()`에 `.catch`를 추가하면 거부된 Promise를 처리할 수 있다.\r\n\r\n```js\r\nasync function f() {\r\n  let response = await fetch(\"http://유효하지-않은-주소\")\r\n}\r\n\r\n// f()는 거부 상태의 프라미스가 된다.\r\nf().catch(alert) // TypeError: failed to fetch\r\n```\r\n\r\n### async/await는 Promise.all과도 함께 쓸 수 있다.\r\n\r\n여러 개의 Promise가 모두 처리되길 기다려야 하는 상황이라면 이 Promise들을 `Promise.all`로 감싸고 여기에 `await`를 붙여 사용할 수 있다.\r\n\r\n```js\r\n// Promise 처리 결과가 담긴 배열을 기다린다.\r\nlet results = await Promise.all([\r\n  fetch(url1),\r\n  fetch(url2),\r\n  ...\r\n])\r\n```\r\n\r\n실패한 Promise에서 발생한 에러는 보통 에러와 마찬가지로 `Promise.all`로 전파된다. 에러 때문에 생긴 예외는 `try...catch`로 감싸 잡을 수 있다.\r\n\r\n## 그래서 실무에서는 어떻게 써야해?\r\n\r\n보통 `axios`를 이용해서 API 요청을 보내고 받아온다. 아래는 GPT-4에게 `try~catch`문과  \r\n`async/await`를 적절하게 사용한 best practice 작성을 부탁한 코드다.\r\n\r\n### 1. 타입 정의\r\n\r\n```ts\r\ninterface ApiResponse {\r\n  success: boolean\r\n  data: any // 실제 응답 구조에 맞게 타입을 상세하게 정의\r\n}\r\n```\r\n\r\n### 2. Axios 인스턴스 생성\r\n\r\n```ts\r\nimport axios from \"axios\"\r\n\r\nconst client = axios.create({\r\n  baseURL: \"https://api.example.com\", // 보통 서버리스 함수 등으로 API 숨김. 여기선 skip\r\n  headers: {\r\n    \"Content-Type\": \"application/json\",\r\n  },\r\n})\r\n```\r\n\r\n### 3. API 요청 함수 작성\r\n\r\n```ts\r\nasync function fetchSomeData(): Promise<ApiResponse> {\r\n  try {\r\n    const response = await client.get<ApiResponse>(\"/data\")\r\n    return response.data\r\n  } catch (error) {\r\n    if (axios.isAxiosError(error)) {\r\n      // Axios 에러 처리\r\n      console.error(\"Axios error:\", error.response)\r\n    } else {\r\n      // 기타 에러 처리\r\n      console.error(\"Unexpected error:\", error)\r\n    }\r\n    throw error\r\n  }\r\n}\r\n```\r\n\r\n### 4. 사용 예시\r\n\r\n```ts\r\nasync function main() {\r\n  try {\r\n    const data = await fetchSomeData()\r\n    console.log(data)\r\n  } catch (error) {\r\n    console.error(\"Error fetching data:\", error)\r\n  }\r\n}\r\n\r\nmain()\r\n```\r\n"},{"excerpt":"MPA(Multiple Page Application)이란? 여러 개의 Page로 구성된 Application이다. MAP는 SSR 방식으로 렌더링한다.\n새로운 페이지를 요청할 때마다 서버에서 렌더링된 정적 리소스(HTML, CSS, Javascript)가 다운로드된다. 페이지를 이동하거나 새로고침하면 전체 페이지를 다시 렌더링한다. MPA의 장점 SEO…","fields":{"slug":"/spa-mpa/"},"frontmatter":{"date":"March 05, 2024","title":"🤔 SPA vs MPA와 SSR vs CSR","tags":["MPA","SPA","CSR","SSR"]},"rawMarkdownBody":"\r\n## MPA(Multiple Page Application)이란?\r\n\r\n- 여러 개의 Page로 구성된 Application이다.\r\n- MAP는 SSR 방식으로 렌더링한다.\r\n  새로운 페이지를 요청할 때마다 서버에서 렌더링된 정적 리소스(HTML, CSS, Javascript)가 다운로드된다. 페이지를 이동하거나 새로고침하면 전체 페이지를 다시 렌더링한다.\r\n\r\n### MPA의 장점\r\n\r\n1. **SEO 최적화**\r\n\r\n- MPA는 완성된 형태의 HTML 파일을 서버로부터 전달받는다. 이때 각 페이지가 독립적인 URL을 가지므로 검색 엔진이 페이지를 쉽게 색인화(Indexing)을 할 수 있다. 따라서 SEO(Search Engine Optimization)에 유리하다.\r\n\r\n2. **초기 로딩 속도가 빠르다.**\r\n   - 서버에서 그려진 HTML을 렌더링하기 때문이다.\r\n\r\n### MPA의 단점\r\n\r\n1. **새로운 페이지로 이동하면 '깜빡'이는 현상이 있다.**\r\n\r\n   - 페이지 요청마다 전체 페이지를 다시 렌더링(새로고침)을 한다.\r\n\r\n2. **페이지 이동 시 불필요한 템플릿도 중복해서 로딩**\r\n3. **서버 렌더링에 따른 부하**\r\n\r\n## SPA(Single Page Application)이란?\r\n\r\n- SPA는 말 그대로 한 개의 페이지로 구성된 애플리케이션을 말한다.\r\n- SPA는 보통 CSR(Client Side Rendering) 방식으로 렌더링한다.\r\n  - 그러나 SPA는 SSR이나 SSG와 같은 다른 렌더링 방식을 사용할 수도 있다.  \r\n    예를 들어, Next.js는 SPA를 구현하면서도 SSR이나 SSG를 지원한다.\r\n- 처음 페이지 로딩 시 웹 애플리케이션의 모든 정적 리소스(Html, Css, Javascript ...)를  \r\n  한 번에 다운받는다. 따라서 사용자가 처음 접속할 때 로딩 시간이 길 수 있다.\r\n- 최초 페이지를 로딩한 시점부터는 페이지 리로딩없이 필요한 부분만 서버로부터 받아서 화면을 갱신한다.(Ajax 덕분에 페이지를 다시 로드할 필요가 없다) 필요한 부분만 갱신하기 때문에 자연스러운 페이지 이동과 UX를 제공한다.\r\n\r\n### SPA의 장점\r\n\r\n1. **자연스러운 사용자 경험(UX)과 빠른 속도**\r\n\r\n   - 전체 페이지를 새로고침하지 않고 필요한 데이터만 바꾸므로 마치 네이티브 앱과 같이 빠르고 '깜빡' 거림이 없다.\r\n\r\n2. **네트워크 트래픽 감소**\r\n\r\n   - 서버에 전체 페이지를 요청하는 대신 필요한 데이터만 요청하므로 네트워크 트래픽이 감소한다.\r\n\r\n3. **백엔드 서버 부하 감소**\r\n\r\n### SPA의 단점\r\n\r\n1. **초기 로딩 시간(Code Splitting으로 해결 가능)**\r\n\r\n   - SPA는 처음 로딩할 때 애플리케이션의 전체를 로드해야 하므로 초기 로딩 시간이 길 수 있다.\r\n\r\n2. **SEO에 취약(SSR로 해결 가능)**\r\n   - 웹 크롤러가 Javascript를 완벽하게 해석하지 못하는 경우, 페이지의 내용이 제대로 색인화(Indexing)되지 않을 수 있다.\r\n\r\n## SSR vs CSR\r\n\r\n![](https://raw.githubusercontent.com/leedawnn/leedawnn.github.ioo/master/assets/ssr.png)\r\n\r\nSSR은 서버에서 페이지를 렌더링하는 방식이다. 사용자가 웹 페이지에 접속하면, 서버에서 해당 페이지를 렌더링하여 HTML 형태로 사용자에게 전송한다. 이 방식은 전통적인 웹 애플리케이션에서 주로 사용되었으나, 최근에는 React, Vue 등의 라이브러리나 프레임워크에도 SSR을 지원하고 있다.\r\n\r\n### SSR의 장점\r\n\r\n1. **초기 로딩 속도가 짧기 때문에 사용자가 빠르게 화면을 볼 수 있다.**\r\n2. **SEO에 효율적이다.**\r\n\r\n### SSR의 단점\r\n\r\n1. **페이지를 요청할 때마다 필요한 부분만 바꿔서 보여주는 것이 아니라 새로운 페이지를 보여주기 때문에 화면이 깜빡이는 현상이 있다.**\r\n2. **서버에 계속 요청을 해야하기 때문에 서버 부하가 커진다.**\r\n3. **동적으로 데이터를 처리하는 파일을 받아노는 것이 느리면, 사용자가 아무리 클릭을 해도 반응하지 않는 경우가 생기기도 한다.**\r\n\r\n![](https://raw.githubusercontent.com/leedawnn/leedawnn.github.ioo/master/assets/csr.png)\r\n\r\nCSR은 클라이언트 측에서 페이지를 렌더링하는 방식이다. 사용자가 웹 애플리케이션에 처음 접속하면, 서버로부터 필요한 모든 자바스크립트 파일을 다운로드 받는다. 이후 페이지의 렌더링은 클라이언트 측에서 이루어진다. 사용자의 상호작용에 따라 필요한 데이터만 서버로부터 가져와서 페이지르르 업데이트한다. 이 방식은 SPA에서 주로 사용된다.\r\n\r\n### CSR의 장점\r\n\r\n1. **사용자 경험이 좋고, 서버 부하가 적다.**\r\n2. **한 번의 로딩 후에는 서버로부터 새로운 페이지를 요청하지 않기 때문에 반응성이 좋다.**\r\n\r\n### CSR의 단점\r\n\r\n1. **초기 로딩 속도가 길다.**\r\n2. **SEO에 문제가 있을 수 있다. 웹 크롤러가 자바스크립트를 완벽하게 해석하지 못하는 경우, 페이지의 내용이 제대로 색인화되지 않을 수 있다.**\r\n"},{"excerpt":"","fields":{"slug":"/nextjs-rendering/"},"frontmatter":{"date":"March 05, 2024","title":"↗️ Next.js의 렌더링 방식 이해하기","tags":["nextjs","SSR","SSG","ISR"]},"rawMarkdownBody":"\r\n##\r\n"},{"excerpt":"순수 함수란 무엇인가? 순수 함수란 사이드 이펙트가 없는 함수, 즉 함수의 실행이 외부에 영향을 끼치지 않는 함수를 뜻하고 입력으로 전달된 값을 수정하지 않는 불변성을 가지고 있다. 따라서 순수함수는 어떠한 전달인자가 주어지더라도 항상 똑같은 값이 리턴됨을 보장한다. 사이드 이펙트를 만들지 않는다. 함수는 입력받은 값만을 가지고 결과를 반환하며, 그 외 …","fields":{"slug":"/pure-components/"},"frontmatter":{"date":"March 04, 2024","title":"🐳 React에서의 순수 컴포넌트","tags":["react","pure function","components"]},"rawMarkdownBody":"\r\n## 순수 함수란 무엇인가?\r\n\r\n순수 함수란 사이드 이펙트가 없는 함수, 즉 함수의 실행이 외부에 영향을 끼치지 않는 함수를 뜻하고 입력으로 전달된 값을 수정하지 않는 불변성을 가지고 있다. 따라서 순수함수는 어떠한 전달인자가 주어지더라도 항상 똑같은 값이 리턴됨을 보장한다.\r\n\r\n- **사이드 이펙트를 만들지 않는다.** 함수는 입력받은 값만을 가지고 결과를 반환하며, 그 외 어떤 외부 상태도 변경하지 않는다.\r\n- **동일 입력, 동일 출력.** 동일한 입력에 대해 순수 함수는 언제나 동일한 결과를 출력한다.\r\n\r\n### 사이드 이펙트란?\r\n\r\n함수의 입력 외에도 함수의 결과에 영향을 미치는 요인이다. 대표적으로 네트워크 요청,  \r\nAPI 호출이 side effect이다.\r\n\r\n### 순수 함수 개념이 중요한 이유는?\r\n\r\n사이드 이펙트를 줄이고, 모듈화 수준을 높이는 함수형 프로그래밍의 특징, 즉 순수 함수는 평가 시점이 무관하다는 특징으로 인해 효율적인 로직을 구성할 수 있다.\r\n\r\n## React에서의 순수 컴포넌트란?\r\n\r\nReact는 순수 함수를 중심으로 설계되었다. 모든 컴포넌트가 순수 함수라고 가정한다.  \r\n즉, 우리가 작성하는 React 컴포넌트는 동일한 입력이 주어졌을 때 항상 동일한 JSX를 반환해야 한다.\r\n\r\n다음 코드는 불순한 컴포넌트의 예시이다. 😒\r\n\r\n```js\r\nlet guest = 0\r\n\r\nfunction Cup() {\r\n  // Bad : 기존 변수를 변경합니다!\r\n  guest = guest + 1\r\n  return <h2>Tea cup for guest #{guest}</h2>\r\n}\r\n\r\nexport default function TeaSet() {\r\n  return (\r\n    <>\r\n      <Cup />\r\n      <Cup />\r\n      <Cup />\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n이 컴포넌트는 외부에서 선언된 `guest` 변수를 읽고 쓰고 있다. **즉, 이 컴포넌트는 호출할 때마다 다른 JSX가 생성된다는 뜻이다!** 게다가 다른 컴포넌트가 `guest`를 읽으면 렌더링된 시점에 따라 JSX도 다르게 생성된다.\r\n\r\n`guest`를 props로 전달함으로써 이 컴포넌트를 고칠 수 있다. 😊\r\n\r\n```js\r\nfunction Cup({ guest }) {\r\n  return <h2>Tea cup for guest #{guest}</h2>\r\n}\r\n\r\nexport default function TeaSet() {\r\n  return (\r\n    <>\r\n      <Cup guest={1} />\r\n      <Cup guest={2} />\r\n      <Cup guest={3} />\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n이제 컴포넌트가 반환하는 JSX는 `guest` props에만 의존하므로 순수하다. 각 컴포넌트는 렌더링 중에 다른 컴포넌트와 조율하거나 의존하지 말고 \"스스로 생각\"하게 해야한다.\r\n\r\n## local mutation (지역 변이) : 컴포넌트의 작은 비밀\r\n\r\n위의 예시에서는 컴포넌트가 렌더링하는 동안 기존 변수를 변경하는 것이 문제였다. 이를 \"**변이(mutation)**\" 이라고 부른다. 순수 함수는 함수의 범위를 벗어난 변수나 호출 전에 생성된 객체를 변이하지 않는다. 그러면 순수하지 않기 때문이다.\r\n\r\n하지만 **렌더링하는 동안 '방금' 생성한 변수와 객체를 변경하는 것은 괜찮다.** 이 예제에서는 배열을 생성하고 이를 `cups` 변수에 할당한 다음 컵 12개를 그 안에 push 한다.\r\n\r\n```js\r\nfunction Cup({ guest }) {\r\n  return <h2>Tea cup for guest #{guest}</h2>\r\n}\r\n\r\nexport default function TeaGathering() {\r\n  let cups = []\r\n  for (let i = 1; i < 12; i++) {\r\n    cups.push(<Cup key={i} guest={i} />)\r\n  }\r\n\r\n  return cups\r\n}\r\n```\r\n\r\n`cups` 변수나 배열이 `TeaGathering` 함수 외부에서 생성되었다면 이는 큰 문제가 될 것이다! 해당 배열에 항목을 밀어 넣음으로써 기존 객체를 변경하게 될 것이기 때문이다.\r\n\r\n하지만 `TeaGathering` 내부에서 동일한 렌더링 중에 생성했기 때문에 괜찮다. `TeaGathering` 외부의 어떤 코드도 이런 일이 일어났다는 것을 알 수 없다. 이를 \"**지역 변이(Local Mutation)**\"이라고 하며, 컴포넌트의 작은 비밀과 같다.\r\n\r\n## 사이드 이펙트를 일으킬 수 있는 곳\r\n\r\n함수형 프로그래밍은 순수성에 크게 의존하지만, 언젠가는 어딘가에서 무언가는 바뀌어야 한다. 이것이 바로 프로그래밍의 핵심이다! 화면 업데이트, 애니메이션 시작, 데이터 변경과 같은 이러한 변경을 **사이드 이펙트**라고 하며, 렌더링 중에 일어나는 것이 아니라 \"부수적으로\" 일어나는 일이다.\r\n\r\n**React에서 사이드 이펙트는 보통 이벤트 핸들러에 속한다.** 이벤트 핸들러가 컴포넌트 내부에 정의되어 있긴 하지만 렌더링 중에는 실행되지 않는다! **따라서 이벤트 핸들러는 순수할 필요가 없다.**\r\n\r\n다른 모든 옵션을 다 사용했는데도 사이드 이펙터에 적합한 이벤트 핸들러를 찾을 수 없다면, 컴포넌트에서 `useEffect` 호출을 통해 반환된 JSX에 이벤트 핸들러를 첨부할 수 있다. 이렇게 하면 나중에 렌더링 후 사이드 이펙트가 허용될 때 React가 이를 실행하도록 지시한다. **하지만 이 방법은 최후의 수단으로 사용해야한다.**\r\n\r\n## 요약\r\n\r\n- 컴포넌트는 순수해야 한다.\r\n  - **사이드 이펙트를 만들지 않는다.** 함수는 입력받은 값만을 가지고 결과를 반환하며, 그 외 어떤 외부 상태도 변경하지 않는다.\r\n  - **동일 입력, 동일 출력.** 동일한 입력에 대해 순수 함수는 언제나 동일한 결과를 출력한다.\r\n- 컴포넌트가 렌더링에 사용하는 어떠한 입력값도 변이해서는 안된다. 여기에는 props, state 및 context가 포함된다. 화면을 업데이트하려면 기존 객체를 변이하는 대신 `setState`를 사용하자.\r\n- 컴포넌트의 로직을 반환하는 JSX 안에 표현하기 위해 노력하자. \"무언가를 변경\"해야 할 때는 보통 이벤트 핸들러에서 이 작업을 수행하고자 할 것이다. 최후의 수단으로 `useEffect`를 사용할 수 있다.\r\n"},{"excerpt":"로그인을 구현할 때 어떤 방법이 있을까? 프론트엔드에서 로그인을 구현하는 방법에는 여러 가지가 있다. 세션 기반 인증 : 사용자가 로그인을 하면 서버는 사용자의 정보를 세션에 저장하고, 클라이언트에 세션 ID를 쿠키로 전송한다. 클라이언트는 이 쿠키를 보관하고 있다가 다음 요청 시 쿠키를 함께 보내 서버에서 인증을 받는다. 서버는 세션 ID를 통해 사용자…","fields":{"slug":"/login-logics/"},"frontmatter":{"date":"February 28, 2024","title":"🔧 로그인 로직 이해하기","tags":["login","jwt","session","cookie"]},"rawMarkdownBody":"\r\n## 로그인을 구현할 때 어떤 방법이 있을까?\r\n\r\n프론트엔드에서 로그인을 구현하는 방법에는 여러 가지가 있다.\r\n\r\n- **세션 기반 인증** : 사용자가 로그인을 하면 서버는 사용자의 정보를 세션에 저장하고, 클라이언트에 세션 ID를 쿠키로 전송한다. 클라이언트는 이 쿠키를 보관하고 있다가 다음 요청 시 쿠키를 함께 보내 서버에서 인증을 받는다. 서버는 세션 ID를 통해 사용자의 정보를 찾아 인증한다.\r\n- **토큰 기반 인증 (jwt ..)** : 사용자가 로그인을 하면 서버는 사용자의 정보를 토큰에 담아 클라이언트에게 전송한다. 클라이언트는 이 토큰을 보관하고 있다가 다음 요청 시 토큰을 함께 보내 서버에서 인증을 받는다. 서버는 토큰을 해독해 사용자의 정보를 확인하고 인증한다.\r\n- **OAuth** : 사용자가 이미 가입한 다른 서비스의 계정을 이용해 로그인하는 방법이다. 예를 들어, 구글이나 페이스북(meta) 계정으로 로그인하는 것이 이에 해당한다. 이 방식은 OAuh 프로토콜을 사용하며, 사용자가 서비스에 개인 정보를 제공하는 것 없이도 인증을 할 수 있다.\r\n- **Firebase Auth** : Firebase는 인증에 필요한 백엔드 서비스를 제공한다. 클라이언트 단에서 REST API를 사용하기만 하면 인증을 구현할 수 있다.\r\n\r\nOAuth와 같은 다른 서비스를 이용하여 인증을 구현하는 방식을 제외하고, JWT와 세션을 이용한 로그인 로직에 대해 알아보자.\r\n\r\n## JWT (JSON Web Token)\r\n\r\n- **구현 방법**\r\n  1. 사용자가 로그인에 성공하면 서버에서 JWT를 생성하여 사용자에게 반환한다.\r\n  2. 사용자는 이 JWT를 클라이언트 측에 저장하고, 이후 요청에 대해 HTTP 헤더에 포함시켜 인증한다.\r\n  3. 서버는 이 토큰을 디코딩하여 유효성을 검증하고 요청을 처리한다.\r\n- **장점**\r\n  - 서버 측에서 세션 상태를 유지할 필요가 없으므로 Stateless하고 확장성이 좋다.\r\n  - 또한, 토큰은 클라이언트 측에서 저장되므로 서버의 부하를 줄일 수 있다.\r\n- **단점**\r\n  - JWT는 상대적으로 크기가 크므로, 매 요청마다 토큰을 포함시켜 보내야 하기 때문에 네트워크 부하가 생길 수 있다.\r\n  - 또한, 한번 발급된 토큰은 유효기간이 만료될 때까지 계속 유효하므로 보안 문제가 발생할 수 있다.\r\n\r\n## 세션\r\n\r\n- **구현 방법**\r\n  1. 사용자가 로그인에 성공하면 서버에서 세션 ID를 생성하여 사용자에게 반환한다.\r\n  2. 이 세션 ID와 매칭되는 사용자 정보를 서버에 저장한다.\r\n  3. 사용자는 이후 요청에 대해 세션 ID를 포함시켜 서버에 전송하고, 서버는 이 세션 ID를 통해 사용자를 식별한다.\r\n- **장점**\r\n  - 사용자 정보는 서버에 저장되므로, 보안성이 상대적으로 높다.\r\n  - 서버에서 사용자의 상태 정보를 관리하므로 상세한 컨트롤이 가능하다.\r\n- **단점**\r\n  - 사용자가 많아질수록 서버의 메모리를 많이 차지하게 되므로 확장성에 문제가 생길 수 있다.\r\n  - 서버 기반의 인증 방식이므로 서버의 부하가 증가할 수 있다.\r\n"},{"excerpt":"컴포넌트를 분리하는 방법에는 어떤 것이 있을까? 컴포넌트를 분리하는 방법론들에 따라, 컴포넌트를 분리하는 \"기준\"이 달라지게 된다. 보통 컴포넌트를 분리하는 방법론은 아래와 같이 나뉜다. 컴포넌트의 관심사 분리(Separation of Concerns, SoC) headless 컴포넌트 SOLID, 단일 책임의 원칙 이 방법론들은 각각 어떤 기준을 가지고…","fields":{"slug":"/react-components/"},"frontmatter":{"date":"February 26, 2024","title":"🚀 React에서 컴포넌트를 분리하는 기준","tags":["react","components"]},"rawMarkdownBody":"\r\n## 컴포넌트를 분리하는 방법에는 어떤 것이 있을까?\r\n\r\n컴포넌트를 분리하는 방법론들에 따라, 컴포넌트를 분리하는 \"기준\"이 달라지게 된다.  \r\n보통 컴포넌트를 분리하는 방법론은 아래와 같이 나뉜다.\r\n\r\n1. **컴포넌트의 관심사 분리(Separation of Concerns, SoC)**\r\n2. **headless 컴포넌트**\r\n3. **SOLID, 단일 책임의 원칙**\r\n\r\n이 방법론들은 각각 어떤 기준을 가지고 있는지 하나씩 알아보자.\r\n\r\n## 컴포넌트의 관심사 분리(Separation of Concerns, SoC)\r\n\r\n### 관심사의 분리란?\r\n\r\n- 관심사의 분리란 복잡한 코드를 비슷한 기능을 하는 코드끼리 별도로 관리하는 것을 말한다.\r\n- 프로그램을 구별된 '개개의 관심사를 해결하는 부분'으로 분리하는 디자인 원칙이다.\r\n- 컴포넌트 별로 관심사를 분리하면 확장성과 재사용성을 높일 수 있다.\r\n\r\n### 컴포넌트를 분리하는 이유\r\n\r\n- 컴포넌트는 의도에 따라 **UI를 표현**하고자 하거나 **동작하는 로직**을 담을 수 있다.\r\n- 이처럼 컴포넌트는 재사용할 수 있는 최소 UI 단위임에도 불구하고, 웹의 복잡도와 해당 컴포넌트에서 수행하려고 하는 역할에 따라 얼마든지 복잡해질 수 있다.\r\n- 따라서 '관심사의 분리' 원칙에 따라 컴포넌트를 분리해서 관리하여야 한다.\r\n"},{"excerpt":"스터디에 참여한 이유 자바스크립트에 대한 기초가 부족한 채로 SPA 프레임워크를 사용하여 프로젝트를 해오니 간단한 오류 하나 잡는 것에도 시간이 많이 들었다. 최신 기술 스택들을 따라가기 보다는 기초가 튼튼한 개발자가 되어야겠다고 마음을 먹고, okky를 통해서 스터디를 찾아 참여하게 되었다. 스터디 진행 스터디는 게더타운에서 평일 밤 10시에 모여 진도…","fields":{"slug":"/js-deep-dive-study/"},"frontmatter":{"date":"May 01, 2022","title":"🔥 모던 자바스크립트 Deep Dive 스터디 회고","tags":["javascript","study","회고"]},"rawMarkdownBody":"\r\n## 스터디에 참여한 이유\r\n\r\n자바스크립트에 대한 기초가 부족한 채로 SPA 프레임워크를 사용하여 프로젝트를 해오니 간단한 오류 하나 잡는 것에도 시간이 많이 들었다. 최신 기술 스택들을 따라가기 보다는 기초가 튼튼한 개발자가 되어야겠다고 마음을 먹고, okky를 통해서 스터디를 찾아 참여하게 되었다.\r\n\r\n## 스터디 진행\r\n\r\n<p align=\"center\">\r\n  <img src=\"https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9791158392239.jpg\" width=\"300\" />\r\n</p>\r\n\r\n스터디는 게더타운에서 평일 밤 10시에 모여 진도에 맞는 챕터를 각자 1시간동안 읽고, 토론을 하는 식으로 진행했다. 보통 30분 정도 토론을 했고, 길어지면 12시를 넘기는 날도 있었다.\r\n\r\n진도를 다 끝내는 데 2달 정도 걸렸다. 학생, 취준생, 현업자로 다양한 사람들로 구성되었다. ~~마지막엔 나 포함 2명밖에 남지 않았지만..~~ 스터디 내내 개발 초보가 보는 관점과 현업에 계신 분의 관점이 이렇게 다르구나를 느낄 수 있었다. 역시 아는 만큼 보인다..!\r\n\r\n[모던 자바스크립트 Deep Dive 스터디](https://github.com/leedawnn/javascript-deep-dive) 레포지토리를 통해 진도 체크를 하였고, 자유롭게 글을 올리는 식으로 진행되었다. 난 TIL을 해오고 있었기 때문에, TIL에 새롭게 배우게 된 내용을 따로 정리했다. 끝나고보니 TIL은 한 눈에 보기가 힘들어서.. 그냥 스터디 레포에 올릴 걸 그랬다.. 🥲\r\n\r\n[3월 TIL](https://github.com/leedawnn/TIL/tree/main/Daily/2022_03), [4월 TIL](https://github.com/leedawnn/TIL/tree/main/Daily/2022_04)을 보면 스터디 내용을 확인할 수 있다. 😃\r\n\r\n## 회고\r\n\r\n<p align=\"center\">\r\n  <img src=\"/js-deep-dive-done.png\" width=\"400\" />\r\n</p>\r\n\r\n총 49 챕터, 900페이지가 넘어가는 배게 같은 책을 혼자 읽었다면 이렇게 재미있게 읽지 못했을 것 같다. 이해가 잘 가지 않아서 갑갑한 마음이 들 때면 현업에 계신 분들이 강의도 해주시고ㅋㅋ 면접 관련한 꿀팁들도 마구 쏟아내 주셔서 감사한 마음이 크다. 😊 특히, 마지막까지 함께 해주신 토니님께 넘나 감사드린다.. 이력서까지 공유해주시고, 취준 방향에 대해서도 많은 얘기를 해주셨다 ㅠㅠ 좋은 사람들과 행복한 스터디를 하고 나니 더 많은 것을 배우고 싶은 마음이 든다 ㅎㅎ\r\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}