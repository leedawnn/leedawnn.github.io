<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed of leedawn]]></title><description><![CDATA[안녕하세요. 주니어 프론트엔드 개발자 이지혜입니다.]]></description><link>https://leedawnn.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 13 Mar 2024 06:23:39 GMT</lastBuildDate><item><title><![CDATA[🦚 Ajax와 fetch, Axios는 어떻게 다를까?]]></title><description><![CDATA[Ajax (Asynchronous Javascript and XML) Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있다. 즉 Ajax…]]></description><link>https://leedawnn.github.io/ajax-axios/</link><guid isPermaLink="false">https://leedawnn.github.io/ajax-axios/</guid><pubDate>Wed, 13 Mar 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Ajax (Asynchronous Javascript and XML)&lt;/h2&gt;
&lt;p&gt;Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있다. 즉 Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹페이지의 일부분만 표시 할 수 있다.&lt;/p&gt;
&lt;h3&gt;동작 방식&lt;/h3&gt;
&lt;p&gt;Ajax는 &lt;code class=&quot;language-text&quot;&gt;XMLHttpRequest&lt;/code&gt; 객체를 사용하여 서버와 통신한다. 이 객체를 통해 데이터를 비동기적으로 교환할 수 있으며, 페이지 전체를 새로고침하지 않고도 일부분만을 업데이트할 수 있다.&lt;/p&gt;
&lt;h3&gt;사용법&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; xhr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;XMLHttpRequest&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// XMLHttpRequest 객체 생성&lt;/span&gt;

xhr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;GET&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;url-to-the-server&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 요청 초기화 (HTTP 요청 메서드, 요청을 보낼 서버의 url, 비동기적으로 요청할 것인지 boolean)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 응답 처리 이벤트 핸들러 (xhr.readyState === 4는 요청 완료되었음을 나타냄)&lt;/span&gt;
xhr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onreadystatechage&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;xhr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;readyState &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; xhr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;status &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;xhr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;responseText&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 서버로부터 받은 데이터 처리&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

xhr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 요청 전송&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;한계&lt;/h3&gt;
&lt;p&gt;Ajax는 &lt;code class=&quot;language-text&quot;&gt;XMLHttpRequest&lt;/code&gt; 객체를 사용하여 비동기 통신을 구현한다. 하지만 사용법이 복잡하고, 콜백 지옥(callback hell)과 같은 문제가 발생할 수 있다. 또한 JSON 데이터를 처리하기 위한 추가적인 변환 작업이 필요하다.&lt;/p&gt;
&lt;h3&gt;Fetch의 등장 배경&lt;/h3&gt;
&lt;p&gt;Fetch API는 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;를 기반으로 하여 비동기 통신을 더욱 간결하고 직관적으로 만들 수 있게 해준다. Fetch는 &lt;code class=&quot;language-text&quot;&gt;XMLHttpRequest&lt;/code&gt;보다 더 유연하고 강력한 기능을 제공하며, 직접적으로 JSON을 지원하여 데이터 처리가 훨씬 간편해졌다.&lt;/p&gt;
&lt;h2&gt;Fetch API&lt;/h2&gt;
&lt;p&gt;Fetch API는 브라우저의 &lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt; 객체에 내장되어 있으며, &lt;code class=&quot;language-text&quot;&gt;Request&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;Response&lt;/code&gt; 객체를 사용하여 요청과 응답을 쉽게 처리할 수 있다.&lt;/p&gt;
&lt;h3&gt;사용법&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;url&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; options&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;response: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// JSON 데이터로 변환&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;error: &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fetch는 첫번째 인자로 &lt;code class=&quot;language-text&quot;&gt;url&lt;/code&gt;, 두번째 인자로 &lt;code class=&quot;language-text&quot;&gt;옵션 객체&lt;/code&gt;를 받고, &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt; 타입의 객체를 반환한다. 반환된 객체는 API 호출이 성공했을 경우에는 응답(response) 객체를 &lt;code class=&quot;language-text&quot;&gt;resolve&lt;/code&gt;하고, 실패했을 경우에는 예외(error) 객체를 &lt;code class=&quot;language-text&quot;&gt;reject&lt;/code&gt;한다.&lt;/p&gt;
&lt;h3&gt;한계&lt;/h3&gt;
&lt;p&gt;Fetch API는 많은 개선점을 제공하지만, 여전히 몇 가지 한계가 있다.&lt;br&gt;
예를 들어, Fetch는 요청 시간 초과(timeouts)를 직접적으로 지원하지 않는다. 또한 브라우저 호환성 문제와 일부 기능(진행 상태 추적 등)에 대한 제한이 있을 수 있다.&lt;/p&gt;
&lt;h3&gt;Axios의 등장 배경&lt;/h3&gt;
&lt;p&gt;Axios는 Fetch의 모든 장점을 가지면서도, Fetch의 한계를 극복하기 위해 등장했다. Axios는 요청 시간 초과 설정, 요청 취소, HTTP 상태 코드에 따른 자동 변환, 진행 상태 추적 등 추가적인 기능을 제공한다. 또한 브라우저뿐만 아니라 Node.js 환경에서도 사용할 수 있어서 서버 사이드와 클라이언트 사이드 모두 사용된다.&lt;/p&gt;
&lt;h2&gt;Axios&lt;/h2&gt;
&lt;p&gt;Axios는 HTTP 요청을 보내기 위한 자바스크립트 라이브러리이다. Axios는 내부적으로 &lt;code class=&quot;language-text&quot;&gt;XMLHttpRequest&lt;/code&gt;를 사용하지만, &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt; 기반의 API를 제공하여 보다 쉬운 비동기 처리를 가능하게 한다. 또한, 요청과 응답을 JSON 형태로 자동 변환해주거나 에러 처리 등과 추가적인 기능을 제공한다. 보통 아래와 같이 &lt;code class=&quot;language-text&quot;&gt;async/await&lt;/code&gt;와 함께 사용한다.&lt;/p&gt;
&lt;p&gt;Fetch API와 비교했을 때 차이점을 좀 더 자세히 알아보자면, 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;자동 JSON 변환&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Axios는 &lt;code class=&quot;language-text&quot;&gt;response&lt;/code&gt;를 자동으로 JSON 형태로 변환해준다. 반면, Fetch API는 &lt;code class=&quot;language-text&quot;&gt;response&lt;/code&gt;가 도착했을 때, &lt;code class=&quot;language-text&quot;&gt;.json()&lt;/code&gt;을 호출하여 수동으로 변환해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;에러 처리&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fetch API는 네트워크 오류가 발생하지 않는 한 요청 실패를 액션이 실패로 간주하지 않는다. 즉, 404나 500 같은 서버 에러 상태에서도 &lt;code class=&quot;language-text&quot;&gt;.then()&lt;/code&gt;을 실행한다. 반면, Axios는 2xx 범위 외의 HTTP 상태 코드를 받으면 자동으로 에러를 발생시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;브라우저 지원&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fetch API는 일부 구형 브라우저에서는 기본적으로 지원되지 않을 수 있다. 반면, Axios는 모든 브라우저에서 작동하도록 Promise API를 사용한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;timeout 설정&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Axios는 요청 타임아웃을 설정하는 옵션이 내장되어 있다. Fetch API에서는 이를 직접 구현해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;사용법&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;fetchData&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; response &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; axios&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;url-to-the-server&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Error! : &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;더 자세한 사용법을 알고싶다면, &lt;a href=&quot;https://leedawnn.github.io/error-handling/&quot;&gt;&lt;strong&gt;⚠️ 자바스크립트의 예외 처리&lt;/strong&gt;&lt;/a&gt; 글을 참고!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[⚠️ 자바스크립트의 예외 처리]]></title><description><![CDATA[자바스크립트에서 에러가 발생하면 스크립트는 죽고, 콘솔에 에러가 출력된다. 그러나 문을 사용하면 스크립트가 죽는 걸 방지하고, 에러를 잡아서(catch) 예외 처리를 할 수 있게 된다. try...catch문 try...catch…]]></description><link>https://leedawnn.github.io/error-handling/</link><guid isPermaLink="false">https://leedawnn.github.io/error-handling/</guid><pubDate>Thu, 07 Mar 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트에서 에러가 발생하면 스크립트는 죽고, 콘솔에 에러가 출력된다.&lt;br&gt;
그러나 &lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;문을 사용하면 스크립트가 죽는 걸 방지하고, 에러를 잡아서(catch) 예외 처리를 할 수 있게 된다.&lt;/p&gt;
&lt;h2&gt;try...catch문&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 에러 핸들링&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;try...catch문의 동작은 다음과 같다.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;먼저, &lt;code class=&quot;language-text&quot;&gt;try {...}&lt;/code&gt; 안의 코드가 실행된다.&lt;/li&gt;
&lt;li&gt;에러가 없다면, &lt;code class=&quot;language-text&quot;&gt;try&lt;/code&gt; 안의 마지막 줄까지 실행되고, &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt; 블록은 건너뛴다.&lt;/li&gt;
&lt;li&gt;에러가 있다면, &lt;code class=&quot;language-text&quot;&gt;try&lt;/code&gt; 안 코드의 실행이 중단되고, &lt;code class=&quot;language-text&quot;&gt;catch(error)&lt;/code&gt; 블록으로 제어 흐름이 넘어간다. 변수 error는 무슨 일이 일어났는지에 대한 설명이 담긴 에러 객체를 포함한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;try {...}&lt;/code&gt; 블록 안에서 에러가 발생해도 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt;에서 에러를 처리하기 때문에 스크립트는 죽지 않는다.&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;는 오직 런타임 에러에만 동작한다.&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;는 실행 가능한(runnable) 코드에만 동작한다. 실행 가능한 코드는 문법적으로 맞는 자바스크립트 코드를 의미한다.&lt;br&gt;
자바스크립트 엔진은 코드를 읽고 난 후 코드를 실행한다. 코드를 읽는 중에 발생하는 에러는 &apos;parse-time 에러&apos;라고 부르는데, 엔진은 이 코드를 이해할 수 없기 때문에 parse-time 에러는 코드 안에서 복구가 불가능하다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;는 유효한 코드에서 발생하는 에러만 처리할 수 있다. 이런 에러를 &apos;런타임 에러(runtime error)&apos; 혹은 &apos;예외(exception)&apos;라고 부른다.&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;문은 동기적으로 동작한다.&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;처럼 스케줄 된 코드에서 발생한 예외는 &lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;문에서 잡아낼 수 없다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    noSuchVariable &lt;span class=&quot;token comment&quot;&gt;// 스크립트는 여기서 죽는다.&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;작동 멈춤&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;에 넘겨진 익명 함수는 &lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;를 떠난 다음에서야 실행되기 때문이다.&lt;br&gt;
스케줄 된 함수 내부의 예외를 잡으려면, &lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;를 반드시 함수 내부에 구현해야한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    noSuchVariable &lt;span class=&quot;token comment&quot;&gt;// 이제 try...catch에서 에러를 핸들링 할 수 있다!&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;에러를 잡았습니다!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;에러 객체&lt;/h3&gt;
&lt;p&gt;에러가 발생하면 자바스크립트는 에러 상세내용이 담긴 객체를 생성한다. 그 후, &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt; 블록에 이 객체를 인수로 전달한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// &amp;lt;-- 에러 객체&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;내장 에러 전체와 에러 객체는 두 가지 주요 프로퍼티를 가진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;
에러 이름. 정의 되지 않은 변수 때문에 발생한 에러라면 &lt;code class=&quot;language-text&quot;&gt;&quot;ReferenceError&quot;&lt;/code&gt;가 이름이 된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;message&lt;/code&gt;
에러 상세 내용을 담고 있는 문자 메시지.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  lalala &lt;span class=&quot;token comment&quot;&gt;// 에러, 변수가 정의되지 않음!&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// ReferenceError&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;message&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// lalala is not defined&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 에러 전체를 보여줄 수도 있다.&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 이때, 에러 객체는 &quot;name: message&quot; 형태의 문자열로 변환된다.&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// ReferenceError: lalala is not defined&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;throw&lt;/code&gt; 연산자&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;throw&lt;/code&gt;문의 주요 용도는 크게 두 가지가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;커스텀 에러 메시지
throw문을 사용하면 특정 조건에서 커스텀 에러 메시지를 생성할 수 있다. 이는 코드를 디버깅하는데 도움이 된다.&lt;br&gt;
또한, 특정 조건에서 발생하는 에러를 사용자에게 더 친절하게 전달할 수 있게 해준다.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;isValid&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;입력 값이 유효하지 않습니다.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;예외를 강제로 발생시키기
코드의 실행을 강제로 중단하고, 해당 에러를 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt; 블록으로 전달할 수 있다. 이는 특정 조건에서 프로그램의 실행을 중단하고, 이를 적절하게 처리하고 싶을 때 유용하다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;에러 다시 던지기&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; json &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;{ &quot;age&quot;: 30 }&apos;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 불완전한 데이터&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  user &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;json&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// user 앞에 let을 붙이는 걸 잊음&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;JSON Error: &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// JSON Error: ReferenceError: user is not defined&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 실제로는 JSON Error가 아님&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 &apos;불완전한 데이터&apos;를 다루려는 목적으로 &lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;를 사용했다. 그런데 catch는 원래 try 블록에서 발생한 모든 에러를 잡으려는 목적으로 만들어졌다. 그런데 위 예시에서 catch는 예상치 못한 에러를 잡아주긴 했지만, 에러 종류와 상관없이 &lt;code class=&quot;language-text&quot;&gt;&quot;JSON Error&quot;&lt;/code&gt; 메시지를 보여준다. 이렇게 에러 종류와 관계없이 동일한 방식으로 에러를 처리하는 것은 디버깅을 어렵게 만들기 때문에 좋지 않다.&lt;/p&gt;
&lt;p&gt;이런 문제를 피하고자 &apos;&lt;strong&gt;다시 던지기(rethrowing)&lt;/strong&gt;&apos; 기술을 사용한다. 규칙은 간단하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;catch는 알고 있는 에러만 처리하고 나머지는 &apos;다시 던져야&apos;한다.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;catch가 모든 에러를 받는다.&lt;/li&gt;
&lt;li&gt;catch(e) {...} 블록 안에서 에러 객체 e를 분석한다.&lt;/li&gt;
&lt;li&gt;에러 처리 방법을 알지 못하면 throw e를 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;보통 에러 타입을 &lt;code class=&quot;language-text&quot;&gt;instanceof&lt;/code&gt; 명령어로 체크한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  user &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;/*...*/&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ReferenceError&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;ReferenceError&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 정의되지 않은 변수에 접근하여 &apos;ReferenceError&apos; 발생&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;async와 await&lt;/h2&gt;
&lt;p&gt;async와 await를 사용하면 Promise를 좀 더 편하게 사용할 수 있다.&lt;/p&gt;
&lt;h3&gt;async 함수&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt;는 function 앞에 위치한다.&lt;/p&gt;
&lt;p&gt;function 앞에 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt;를 붙이면 해당 함수는 항상 Promise를 반환한다. Promise가 아닌 값을 반환하더라도 이행(resolved) 상태의 Promise로 값을 감싸 이행된 Promise가 반환되도록 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;alert&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt;가 붙은 함수는 반드시 Promise를 반환하고, Promise가 아닌 것은 Promise로 감싸 반환한다. 또다른 키워드 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt; 함수 안에서만 동작한다.&lt;/p&gt;
&lt;h3&gt;await&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// await는 async 함수 안에서만 동작한다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; promise&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;자바스크립트는 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt; 키워드를 만나면 Promise가 처리될 때까지 기다린다. 결과는 그 이후 반환된다.&lt;/p&gt;
&lt;p&gt;1초 후 이행되는 Promise를 예시로 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;가 어떻게 동작하는지 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; promise &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;완료!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; promise &lt;span class=&quot;token comment&quot;&gt;// Promise가 이행될 때까지 기다림&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 완료!&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;함수를 호출하고, 함수 본문이 실행되는 도중에 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt; 키워드를 만나면 실행이 잠시 중단되었다가 Promise가 처리되면 실행이 재개된다. 이때 Promise 객체의 result 값이 변수 result에 할당된다. 따라서 위 예시를 실행하면 1초 뒤에 &lt;code class=&quot;language-text&quot;&gt;&quot;완료!&quot;&lt;/code&gt;가 출력된다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;는 말 그대로 Promise가 처리될 때까지 함수 실행을 기다리게 만든다. Promise가 처리되면 그 결과와 함께 실행이 재개된다. Promise가 처리되길 기다리는 동안엔 엔진이 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있기 때문에, CPU 리소스가 낭비되지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;promise.then&lt;/code&gt;보다 더 세련되게 Promise의 result값을 얻을 수 있도록 하는 문법이다.
&lt;code class=&quot;language-text&quot;&gt;promise.then&lt;/code&gt;보다 가독성이 좋고 사용하기도 쉽다.&lt;/p&gt;
&lt;h3&gt;에러 핸들링&lt;/h3&gt;
&lt;p&gt;Promise가 정상적으로 이행되면 &lt;code class=&quot;language-text&quot;&gt;await promise&lt;/code&gt;는 Promise 객체의 result에 저장된 값을 반환한다. 반면 Promise가 거부되면 마치 throw문을 작성한 것처럼 에러가 던져진다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;에러 발생!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 위 코드는 아래 코드와 동일하다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;에러 발생!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;실제 상황에선 Promise가 거부 되기 전에 약간의 시간이 지체되는 경우가 있다. 이런 경우엔 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;가 에러를 던지기 전에 지연이 발생한다.&lt;/p&gt;
&lt;p&gt;await가 던진 에러는 throw가 던진 에러를 잡을 때처럼 &lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;를 사용해 잡을 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; response &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;http://유효하지-않은-주소&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// TypeError: failed to fetch&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;가 없으면 아래 예시의 async 함수 &lt;code class=&quot;language-text&quot;&gt;f()&lt;/code&gt;를 호출해 만든 Promise가 거부 상태가 된다. &lt;code class=&quot;language-text&quot;&gt;f()&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;.catch&lt;/code&gt;를 추가하면 거부된 Promise를 처리할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; response &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;http://유효하지-않은-주소&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// f()는 거부 상태의 프라미스가 된다.&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;alert&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// TypeError: failed to fetch&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;async/await는 Promise.all과도 함께 쓸 수 있다.&lt;/h3&gt;
&lt;p&gt;여러 개의 Promise가 모두 처리되길 기다려야 하는 상황이라면 이 Promise들을 &lt;code class=&quot;language-text&quot;&gt;Promise.all&lt;/code&gt;로 감싸고 여기에 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;를 붙여 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Promise 처리 결과가 담긴 배열을 기다린다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; results &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;url1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;url2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;실패한 Promise에서 발생한 에러는 보통 에러와 마찬가지로 &lt;code class=&quot;language-text&quot;&gt;Promise.all&lt;/code&gt;로 전파된다. 에러 때문에 생긴 예외는 &lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;로 감싸 잡을 수 있다.&lt;/p&gt;
&lt;h2&gt;그래서 실무에서는 어떻게 써야해?&lt;/h2&gt;
&lt;p&gt;보통 &lt;code class=&quot;language-text&quot;&gt;axios&lt;/code&gt;를 이용해서 API 요청을 보내고 받아온다. 아래는 GPT-4에게 &lt;code class=&quot;language-text&quot;&gt;try~catch&lt;/code&gt;문과&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;async/await&lt;/code&gt;를 적절하게 사용한 best practice 작성을 부탁한 코드다.&lt;/p&gt;
&lt;h3&gt;1. 타입 정의&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ApiResponse&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  success&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;boolean&lt;/span&gt;
  data&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 실제 응답 구조에 맞게 타입을 상세하게 정의&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. Axios 인스턴스 생성&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; axios &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;axios&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; client &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; axios&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  baseURL&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;https://api.example.com&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 보통 서버리스 함수 등으로 API 숨김. 여기선 skip&lt;/span&gt;
  headers&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token string-property property&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;application/json&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. API 요청 함수 작성&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fetchSomeData&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;ApiResponse&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; response &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; client&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token generic-function&quot;&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token generic class-name&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;ApiResponse&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/data&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;axios&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isAxiosError&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// Axios 에러 처리&lt;/span&gt;
      &lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Axios error:&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; error&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;response&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 기타 에러 처리&lt;/span&gt;
      &lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Unexpected error:&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; error
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. 사용 예시&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; data &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fetchSomeData&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Error fetching data:&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[🤔 SPA vs MPA와 SSR vs CSR]]></title><description><![CDATA[MPA(Multiple Page Application)이란? 여러 개의 Page로 구성된 Application이다. MAP는 SSR 방식으로 렌더링한다.
새로운 페이지를 요청할 때마다 서버에서 렌더링된 정적 리소스(HTML, CSS…]]></description><link>https://leedawnn.github.io/spa-mpa/</link><guid isPermaLink="false">https://leedawnn.github.io/spa-mpa/</guid><pubDate>Tue, 05 Mar 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;MPA(Multiple Page Application)이란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;여러 개의 Page로 구성된 Application이다.&lt;/li&gt;
&lt;li&gt;MAP는 SSR 방식으로 렌더링한다.
새로운 페이지를 요청할 때마다 서버에서 렌더링된 정적 리소스(HTML, CSS, Javascript)가 다운로드된다. 페이지를 이동하거나 새로고침하면 전체 페이지를 다시 렌더링한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MPA의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;SEO 최적화&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MPA는 완성된 형태의 HTML 파일을 서버로부터 전달받는다. 이때 각 페이지가 독립적인 URL을 가지므로 검색 엔진이 페이지를 쉽게 색인화(Indexing)을 할 수 있다. 따라서 SEO(Search Engine Optimization)에 유리하다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;초기 로딩 속도가 빠르다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서버에서 그려진 HTML을 렌더링하기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;MPA의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;새로운 페이지로 이동하면 &apos;깜빡&apos;이는 현상이 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;페이지 요청마다 전체 페이지를 다시 렌더링(새로고침)을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;페이지 이동 시 불필요한 템플릿도 중복해서 로딩&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서버 렌더링에 따른 부하&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;SPA(Single Page Application)이란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SPA는 말 그대로 한 개의 페이지로 구성된 애플리케이션을 말한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SPA는 보통 CSR(Client Side Rendering) 방식으로 렌더링한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그러나 SPA는 SSR이나 SSG와 같은 다른 렌더링 방식을 사용할 수도 있다.&lt;br&gt;
예를 들어, Next.js는 SPA를 구현하면서도 SSR이나 SSG를 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;처음 페이지 로딩 시 웹 애플리케이션의 모든 정적 리소스(Html, Css, Javascript ...)를&lt;br&gt;
한 번에 다운받는다. 따라서 사용자가 처음 접속할 때 로딩 시간이 길 수 있다.&lt;/li&gt;
&lt;li&gt;최초 페이지를 로딩한 시점부터는 페이지 리로딩없이 필요한 부분만 서버로부터 받아서 화면을 갱신한다.(Ajax 덕분에 페이지를 다시 로드할 필요가 없다) 필요한 부분만 갱신하기 때문에 자연스러운 페이지 이동과 UX를 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;SPA의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;자연스러운 사용자 경험(UX)과 빠른 속도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전체 페이지를 새로고침하지 않고 필요한 데이터만 바꾸므로 마치 네이티브 앱과 같이 빠르고 &apos;깜빡&apos; 거림이 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;네트워크 트래픽 감소&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서버에 전체 페이지를 요청하는 대신 필요한 데이터만 요청하므로 네트워크 트래픽이 감소한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;백엔드 서버 부하 감소&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;SPA의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;초기 로딩 시간(Code Splitting으로 해결 가능)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SPA는 처음 로딩할 때 애플리케이션의 전체를 로드해야 하므로 초기 로딩 시간이 길 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SEO에 취약(SSR로 해결 가능)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;웹 크롤러가 Javascript를 완벽하게 해석하지 못하는 경우, 페이지의 내용이 제대로 색인화(Indexing)되지 않을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;SSR vs CSR&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/leedawnn/leedawnn.github.ioo/master/assets/ssr.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;SSR은 서버에서 페이지를 렌더링하는 방식이다. 사용자가 웹 페이지에 접속하면, 서버에서 해당 페이지를 렌더링하여 HTML 형태로 사용자에게 전송한다. 이 방식은 전통적인 웹 애플리케이션에서 주로 사용되었으나, 최근에는 React, Vue 등의 라이브러리나 프레임워크에도 SSR을 지원하고 있다.&lt;/p&gt;
&lt;h3&gt;SSR의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;초기 로딩 속도가 짧기 때문에 사용자가 빠르게 화면을 볼 수 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SEO에 효율적이다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;SSR의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;페이지를 요청할 때마다 필요한 부분만 바꿔서 보여주는 것이 아니라 새로운 페이지를 보여주기 때문에 화면이 깜빡이는 현상이 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서버에 계속 요청을 해야하기 때문에 서버 부하가 커진다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;동적으로 데이터를 처리하는 파일을 받아노는 것이 느리면, 사용자가 아무리 클릭을 해도 반응하지 않는 경우가 생기기도 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/leedawnn/leedawnn.github.ioo/master/assets/csr.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;CSR은 클라이언트 측에서 페이지를 렌더링하는 방식이다. 사용자가 웹 애플리케이션에 처음 접속하면, 서버로부터 필요한 모든 자바스크립트 파일을 다운로드 받는다. 이후 페이지의 렌더링은 클라이언트 측에서 이루어진다. 사용자의 상호작용에 따라 필요한 데이터만 서버로부터 가져와서 페이지르르 업데이트한다. 이 방식은 SPA에서 주로 사용된다.&lt;/p&gt;
&lt;h3&gt;CSR의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;사용자 경험이 좋고, 서버 부하가 적다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;한 번의 로딩 후에는 서버로부터 새로운 페이지를 요청하지 않기 때문에 반응성이 좋다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;CSR의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;초기 로딩 속도가 길다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SEO에 문제가 있을 수 있다. 웹 크롤러가 자바스크립트를 완벽하게 해석하지 못하는 경우, 페이지의 내용이 제대로 색인화되지 않을 수 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[↗️ Next.js의 렌더링 방식 이해하기]]></title><link>https://leedawnn.github.io/nextjs-rendering/</link><guid isPermaLink="false">https://leedawnn.github.io/nextjs-rendering/</guid><pubDate>Tue, 05 Mar 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;/h2&gt;</content:encoded></item><item><title><![CDATA[🐳 React에서의 순수 컴포넌트]]></title><description><![CDATA[…]]></description><link>https://leedawnn.github.io/pure-components/</link><guid isPermaLink="false">https://leedawnn.github.io/pure-components/</guid><pubDate>Mon, 04 Mar 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;순수 함수란 무엇인가?&lt;/h2&gt;
&lt;p&gt;순수 함수란 사이드 이펙트가 없는 함수, 즉 함수의 실행이 외부에 영향을 끼치지 않는 함수를 뜻하고 입력으로 전달된 값을 수정하지 않는 불변성을 가지고 있다. 따라서 순수함수는 어떠한 전달인자가 주어지더라도 항상 똑같은 값이 리턴됨을 보장한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;사이드 이펙트를 만들지 않는다.&lt;/strong&gt; 함수는 입력받은 값만을 가지고 결과를 반환하며, 그 외 어떤 외부 상태도 변경하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;동일 입력, 동일 출력.&lt;/strong&gt; 동일한 입력에 대해 순수 함수는 언제나 동일한 결과를 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;사이드 이펙트란?&lt;/h3&gt;
&lt;p&gt;함수의 입력 외에도 함수의 결과에 영향을 미치는 요인이다. 대표적으로 네트워크 요청,&lt;br&gt;
API 호출이 side effect이다.&lt;/p&gt;
&lt;h3&gt;순수 함수 개념이 중요한 이유는?&lt;/h3&gt;
&lt;p&gt;사이드 이펙트를 줄이고, 모듈화 수준을 높이는 함수형 프로그래밍의 특징, 즉 순수 함수는 평가 시점이 무관하다는 특징으로 인해 효율적인 로직을 구성할 수 있다.&lt;/p&gt;
&lt;h2&gt;React에서의 순수 컴포넌트란?&lt;/h2&gt;
&lt;p&gt;React는 순수 함수를 중심으로 설계되었다. 모든 컴포넌트가 순수 함수라고 가정한다.&lt;br&gt;
즉, 우리가 작성하는 React 컴포넌트는 동일한 입력이 주어졌을 때 항상 동일한 JSX를 반환해야 한다.&lt;/p&gt;
&lt;p&gt;다음 코드는 불순한 컴포넌트의 예시이다. 😒&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; guest &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Cup&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// Bad : 기존 변수를 변경합니다!&lt;/span&gt;
  guest &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; guest &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h2&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Tea cup &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; guest #&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;guest&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h2&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;TeaSet&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Cup &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Cup &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Cup &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 컴포넌트는 외부에서 선언된 &lt;code class=&quot;language-text&quot;&gt;guest&lt;/code&gt; 변수를 읽고 쓰고 있다. &lt;strong&gt;즉, 이 컴포넌트는 호출할 때마다 다른 JSX가 생성된다는 뜻이다!&lt;/strong&gt; 게다가 다른 컴포넌트가 &lt;code class=&quot;language-text&quot;&gt;guest&lt;/code&gt;를 읽으면 렌더링된 시점에 따라 JSX도 다르게 생성된다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;guest&lt;/code&gt;를 props로 전달함으로써 이 컴포넌트를 고칠 수 있다. 😊&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Cup&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; guest &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h2&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Tea cup &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; guest #&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;guest&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h2&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;TeaSet&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Cup guest&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Cup guest&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Cup guest&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 컴포넌트가 반환하는 JSX는 &lt;code class=&quot;language-text&quot;&gt;guest&lt;/code&gt; props에만 의존하므로 순수하다. 각 컴포넌트는 렌더링 중에 다른 컴포넌트와 조율하거나 의존하지 말고 &quot;스스로 생각&quot;하게 해야한다.&lt;/p&gt;
&lt;h2&gt;local mutation (지역 변이) : 컴포넌트의 작은 비밀&lt;/h2&gt;
&lt;p&gt;위의 예시에서는 컴포넌트가 렌더링하는 동안 기존 변수를 변경하는 것이 문제였다. 이를 &quot;&lt;strong&gt;변이(mutation)&lt;/strong&gt;&quot; 이라고 부른다. 순수 함수는 함수의 범위를 벗어난 변수나 호출 전에 생성된 객체를 변이하지 않는다. 그러면 순수하지 않기 때문이다.&lt;/p&gt;
&lt;p&gt;하지만 &lt;strong&gt;렌더링하는 동안 &apos;방금&apos; 생성한 변수와 객체를 변경하는 것은 괜찮다.&lt;/strong&gt; 이 예제에서는 배열을 생성하고 이를 &lt;code class=&quot;language-text&quot;&gt;cups&lt;/code&gt; 변수에 할당한 다음 컵 12개를 그 안에 push 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Cup&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; guest &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;h2&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Tea cup &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; guest #&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;guest&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;h2&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;TeaGathering&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; cups &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    cups&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Cup key&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; guest&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; cups
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;cups&lt;/code&gt; 변수나 배열이 &lt;code class=&quot;language-text&quot;&gt;TeaGathering&lt;/code&gt; 함수 외부에서 생성되었다면 이는 큰 문제가 될 것이다! 해당 배열에 항목을 밀어 넣음으로써 기존 객체를 변경하게 될 것이기 때문이다.&lt;/p&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;TeaGathering&lt;/code&gt; 내부에서 동일한 렌더링 중에 생성했기 때문에 괜찮다. &lt;code class=&quot;language-text&quot;&gt;TeaGathering&lt;/code&gt; 외부의 어떤 코드도 이런 일이 일어났다는 것을 알 수 없다. 이를 &quot;&lt;strong&gt;지역 변이(Local Mutation)&lt;/strong&gt;&quot;이라고 하며, 컴포넌트의 작은 비밀과 같다.&lt;/p&gt;
&lt;h2&gt;사이드 이펙트를 일으킬 수 있는 곳&lt;/h2&gt;
&lt;p&gt;함수형 프로그래밍은 순수성에 크게 의존하지만, 언젠가는 어딘가에서 무언가는 바뀌어야 한다. 이것이 바로 프로그래밍의 핵심이다! 화면 업데이트, 애니메이션 시작, 데이터 변경과 같은 이러한 변경을 &lt;strong&gt;사이드 이펙트&lt;/strong&gt;라고 하며, 렌더링 중에 일어나는 것이 아니라 &quot;부수적으로&quot; 일어나는 일이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React에서 사이드 이펙트는 보통 이벤트 핸들러에 속한다.&lt;/strong&gt; 이벤트 핸들러가 컴포넌트 내부에 정의되어 있긴 하지만 렌더링 중에는 실행되지 않는다! &lt;strong&gt;따라서 이벤트 핸들러는 순수할 필요가 없다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;다른 모든 옵션을 다 사용했는데도 사이드 이펙터에 적합한 이벤트 핸들러를 찾을 수 없다면, 컴포넌트에서 &lt;code class=&quot;language-text&quot;&gt;useEffect&lt;/code&gt; 호출을 통해 반환된 JSX에 이벤트 핸들러를 첨부할 수 있다. 이렇게 하면 나중에 렌더링 후 사이드 이펙트가 허용될 때 React가 이를 실행하도록 지시한다. &lt;strong&gt;하지만 이 방법은 최후의 수단으로 사용해야한다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;요약&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;컴포넌트는 순수해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;사이드 이펙트를 만들지 않는다.&lt;/strong&gt; 함수는 입력받은 값만을 가지고 결과를 반환하며, 그 외 어떤 외부 상태도 변경하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;동일 입력, 동일 출력.&lt;/strong&gt; 동일한 입력에 대해 순수 함수는 언제나 동일한 결과를 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;컴포넌트가 렌더링에 사용하는 어떠한 입력값도 변이해서는 안된다. 여기에는 props, state 및 context가 포함된다. 화면을 업데이트하려면 기존 객체를 변이하는 대신 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt;를 사용하자.&lt;/li&gt;
&lt;li&gt;컴포넌트의 로직을 반환하는 JSX 안에 표현하기 위해 노력하자. &quot;무언가를 변경&quot;해야 할 때는 보통 이벤트 핸들러에서 이 작업을 수행하고자 할 것이다. 최후의 수단으로 &lt;code class=&quot;language-text&quot;&gt;useEffect&lt;/code&gt;를 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[🔧 로그인 로직 이해하기]]></title><description><![CDATA[로그인을 구현할 때 어떤 방법이 있을까? 프론트엔드에서 로그인을 구현하는 방법에는 여러 가지가 있다. 세션 기반 인증 : 사용자가 로그인을 하면 서버는 사용자의 정보를 세션에 저장하고, 클라이언트에 세션 ID…]]></description><link>https://leedawnn.github.io/login-logics/</link><guid isPermaLink="false">https://leedawnn.github.io/login-logics/</guid><pubDate>Wed, 28 Feb 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;로그인을 구현할 때 어떤 방법이 있을까?&lt;/h2&gt;
&lt;p&gt;프론트엔드에서 로그인을 구현하는 방법에는 여러 가지가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;세션 기반 인증&lt;/strong&gt; : 사용자가 로그인을 하면 서버는 사용자의 정보를 세션에 저장하고, 클라이언트에 세션 ID를 쿠키로 전송한다. 클라이언트는 이 쿠키를 보관하고 있다가 다음 요청 시 쿠키를 함께 보내 서버에서 인증을 받는다. 서버는 세션 ID를 통해 사용자의 정보를 찾아 인증한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;토큰 기반 인증 (jwt ..)&lt;/strong&gt; : 사용자가 로그인을 하면 서버는 사용자의 정보를 토큰에 담아 클라이언트에게 전송한다. 클라이언트는 이 토큰을 보관하고 있다가 다음 요청 시 토큰을 함께 보내 서버에서 인증을 받는다. 서버는 토큰을 해독해 사용자의 정보를 확인하고 인증한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OAuth&lt;/strong&gt; : 사용자가 이미 가입한 다른 서비스의 계정을 이용해 로그인하는 방법이다. 예를 들어, 구글이나 페이스북(meta) 계정으로 로그인하는 것이 이에 해당한다. 이 방식은 OAuh 프로토콜을 사용하며, 사용자가 서비스에 개인 정보를 제공하는 것 없이도 인증을 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Firebase Auth&lt;/strong&gt; : Firebase는 인증에 필요한 백엔드 서비스를 제공한다. 클라이언트 단에서 REST API를 사용하기만 하면 인증을 구현할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OAuth와 같은 다른 서비스를 이용하여 인증을 구현하는 방식을 제외하고, JWT와 세션을 이용한 로그인 로직에 대해 알아보자.&lt;/p&gt;
&lt;h2&gt;JWT (JSON Web Token)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;구현 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 로그인에 성공하면 서버에서 JWT를 생성하여 사용자에게 반환한다.&lt;/li&gt;
&lt;li&gt;사용자는 이 JWT를 클라이언트 측에 저장하고, 이후 요청에 대해 HTTP 헤더에 포함시켜 인증한다.&lt;/li&gt;
&lt;li&gt;서버는 이 토큰을 디코딩하여 유효성을 검증하고 요청을 처리한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서버 측에서 세션 상태를 유지할 필요가 없으므로 Stateless하고 확장성이 좋다.&lt;/li&gt;
&lt;li&gt;또한, 토큰은 클라이언트 측에서 저장되므로 서버의 부하를 줄일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JWT는 상대적으로 크기가 크므로, 매 요청마다 토큰을 포함시켜 보내야 하기 때문에 네트워크 부하가 생길 수 있다.&lt;/li&gt;
&lt;li&gt;또한, 한번 발급된 토큰은 유효기간이 만료될 때까지 계속 유효하므로 보안 문제가 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;세션&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;구현 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 로그인에 성공하면 서버에서 세션 ID를 생성하여 사용자에게 반환한다.&lt;/li&gt;
&lt;li&gt;이 세션 ID와 매칭되는 사용자 정보를 서버에 저장한다.&lt;/li&gt;
&lt;li&gt;사용자는 이후 요청에 대해 세션 ID를 포함시켜 서버에 전송하고, 서버는 이 세션 ID를 통해 사용자를 식별한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자 정보는 서버에 저장되므로, 보안성이 상대적으로 높다.&lt;/li&gt;
&lt;li&gt;서버에서 사용자의 상태 정보를 관리하므로 상세한 컨트롤이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자가 많아질수록 서버의 메모리를 많이 차지하게 되므로 확장성에 문제가 생길 수 있다.&lt;/li&gt;
&lt;li&gt;서버 기반의 인증 방식이므로 서버의 부하가 증가할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[🚀 React에서 컴포넌트를 분리하는 기준]]></title><description><![CDATA[컴포넌트를 분리하는 방법에는 어떤 것이 있을까? 컴포넌트를 분리하는 방법론들에 따라, 컴포넌트를 분리하는 "기준"이 달라지게 된다. 보통 컴포넌트를 분리하는 방법론은 아래와 같이 나뉜다. 컴포넌트의 관심사 분리(Separation of Concerns…]]></description><link>https://leedawnn.github.io/react-components/</link><guid isPermaLink="false">https://leedawnn.github.io/react-components/</guid><pubDate>Mon, 26 Feb 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;컴포넌트를 분리하는 방법에는 어떤 것이 있을까?&lt;/h2&gt;
&lt;p&gt;컴포넌트를 분리하는 방법론들에 따라, 컴포넌트를 분리하는 &quot;기준&quot;이 달라지게 된다.&lt;br&gt;
보통 컴포넌트를 분리하는 방법론은 아래와 같이 나뉜다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;컴포넌트의 관심사 분리(Separation of Concerns, SoC)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;headless 컴포넌트&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOLID, 단일 책임의 원칙&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 방법론들은 각각 어떤 기준을 가지고 있는지 하나씩 알아보자.&lt;/p&gt;
&lt;h2&gt;컴포넌트의 관심사 분리(Separation of Concerns, SoC)&lt;/h2&gt;
&lt;h3&gt;관심사의 분리란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;관심사의 분리란 복잡한 코드를 비슷한 기능을 하는 코드끼리 별도로 관리하는 것을 말한다.&lt;/li&gt;
&lt;li&gt;프로그램을 구별된 &apos;개개의 관심사를 해결하는 부분&apos;으로 분리하는 디자인 원칙이다.&lt;/li&gt;
&lt;li&gt;컴포넌트 별로 관심사를 분리하면 확장성과 재사용성을 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;컴포넌트를 분리하는 이유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;컴포넌트는 의도에 따라 &lt;strong&gt;UI를 표현&lt;/strong&gt;하고자 하거나 &lt;strong&gt;동작하는 로직&lt;/strong&gt;을 담을 수 있다.&lt;/li&gt;
&lt;li&gt;이처럼 컴포넌트는 재사용할 수 있는 최소 UI 단위임에도 불구하고, 웹의 복잡도와 해당 컴포넌트에서 수행하려고 하는 역할에 따라 얼마든지 복잡해질 수 있다.&lt;/li&gt;
&lt;li&gt;따라서 &apos;관심사의 분리&apos; 원칙에 따라 컴포넌트를 분리해서 관리하여야 한다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>