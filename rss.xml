<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed of leedawn]]></title><description><![CDATA[안녕하세요. 주니어 프론트엔드 개발자 이지혜입니다.]]></description><link>https://leedawnn.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 05 Mar 2024 08:17:53 GMT</lastBuildDate><item><title><![CDATA[🤔 SPA vs MPA와 SSR vs CSR]]></title><description><![CDATA[MPA(Multiple Page Application)이란? 여러 개의 Page로 구성된 Application이다. MAP는 SSR 방식으로 렌더링한다.
새로운 페이지를 요청할 때마다 서버에서 렌더링된 정적 리소스(HTML, CSS…]]></description><link>https://leedawnn.github.io/spa-mpa/</link><guid isPermaLink="false">https://leedawnn.github.io/spa-mpa/</guid><pubDate>Tue, 05 Mar 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;MPA(Multiple Page Application)이란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;여러 개의 Page로 구성된 Application이다.&lt;/li&gt;
&lt;li&gt;MAP는 SSR 방식으로 렌더링한다.
새로운 페이지를 요청할 때마다 서버에서 렌더링된 정적 리소스(HTML, CSS, Javascript)가 다운로드된다. 페이지를 이동하거나 새로고침하면 전체 페이지를 다시 렌더링한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MPA의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;SEO 최적화&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MPA는 완성된 형태의 HTML 파일을 서버로부터 전달받는다. 이때 각 페이지가 독립적인 URL을 가지므로 검색 엔진이 페이지를 쉽게 색인화(Indexing)을 할 수 있다. 따라서 SEO(Search Engine Optimization)에 유리하다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;초기 로딩 속도가 빠르다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서버에서 그려진 HTML을 렌더링하기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;MPA의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;새로운 페이지로 이동하면 &apos;깜빡&apos;이는 현상이 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;페이지 요청마다 전체 페이지를 다시 렌더링(새로고침)을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;페이지 이동 시 불필요한 템플릿도 중복해서 로딩&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서버 렌더링에 따른 부하&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;SPA(Single Page Application)이란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SPA는 말 그대로 한 개의 페이지로 구성된 애플리케이션을 말한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SPA는 보통 CSR(Client Side Rendering) 방식으로 렌더링한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그러나 SPA는 SSR이나 SSG와 같은 다른 렌더링 방식을 사용할 수도 있다.&lt;br&gt;
예를 들어, Next.js는 SPA를 구현하면서도 SSR이나 SSG를 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;처음 페이지 로딩 시 웹 애플리케이션의 모든 정적 리소스(Html, Css, Javascript ...)를&lt;br&gt;
한 번에 다운받는다. 따라서 사용자가 처음 접속할 때 로딩 시간이 길 수 있다.&lt;/li&gt;
&lt;li&gt;최초 페이지를 로딩한 시점부터는 페이지 리로딩없이 필요한 부분만 서버로부터 받아서 화면을 갱신한다.(Ajax 덕분에 페이지를 다시 로드할 필요가 없다) 필요한 부분만 갱신하기 때문에 자연스러운 페이지 이동과 UX를 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;SPA의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;자연스러운 사용자 경험(UX)과 빠른 속도&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전체 페이지를 새로고침하지 않고 필요한 데이터만 바꾸므로 마치 네이티브 앱과 같이 빠르고 &apos;깜빡&apos; 거림이 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;네트워크 트래픽 감소&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서버에 전체 페이지를 요청하는 대신 필요한 데이터만 요청하므로 네트워크 트래픽이 감소한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;백엔드 서버 부하 감소&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;SPA의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;초기 로딩 시간(Code Splitting으로 해결 가능)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SPA는 처음 로딩할 때 애플리케이션의 전체를 로드해야 하므로 초기 로딩 시간이 길 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SEO에 취약(SSR로 해결 가능)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;웹 크롤러가 Javascript를 완벽하게 해석하지 못하는 경우, 페이지의 내용이 제대로 색인화(Indexing)되지 않을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;SSR vs CSR&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/leedawnn/leedawnn.github.ioo/master/assets/ssr.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;SSR은 서버에서 페이지를 렌더링하는 방식이다. 사용자가 웹 페이지에 접속하면, 서버에서 해당 페이지를 렌더링하여 HTML 형태로 사용자에게 전송한다. 이 방식은 전통적인 웹 애플리케이션에서 주로 사용되었으나, 최근에는 React, Vue 등의 라이브러리나 프레임워크에도 SSR을 지원하고 있다.&lt;/p&gt;
&lt;h3&gt;SSR의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;초기 로딩 속도가 짧기 때문에 사용자가 빠르게 화면을 볼 수 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SEO에 효율적이다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;SSR의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;페이지를 요청할 때마다 필요한 부분만 바꿔서 보여주는 것이 아니라 새로운 페이지를 보여주기 때문에 화면이 깜빡이는 현상이 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서버에 계속 요청을 해야하기 때문에 서버 부하가 커진다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;동적으로 데이터를 처리하는 파일을 받아노는 것이 느리면, 사용자가 아무리 클릭을 해도 반응하지 않는 경우가 생기기도 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/leedawnn/leedawnn.github.ioo/master/assets/csr.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;CSR은 클라이언트 측에서 페이지를 렌더링하는 방식이다. 사용자가 웹 애플리케이션에 처음 접속하면, 서버로부터 필요한 모든 자바스크립트 파일을 다운로드 받는다. 이후 페이지의 렌더링은 클라이언트 측에서 이루어진다. 사용자의 상호작용에 따라 필요한 데이터만 서버로부터 가져와서 페이지르르 업데이트한다. 이 방식은 SPA에서 주로 사용된다.&lt;/p&gt;
&lt;h3&gt;CSR의 장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;사용자 경험이 좋고, 서버 부하가 적다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;한 번의 로딩 후에는 서버로부터 새로운 페이지를 요청하지 않기 때문에 반응성이 좋다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;CSR의 단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;초기 로딩 속도가 길다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SEO에 문제가 있을 수 있다. 웹 크롤러가 자바스크립트를 완벽하게 해석하지 못하는 경우, 페이지의 내용이 제대로 색인화되지 않을 수 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[🐳 React에서의 순수 컴포넌트]]></title><description><![CDATA[…]]></description><link>https://leedawnn.github.io/pure-components/</link><guid isPermaLink="false">https://leedawnn.github.io/pure-components/</guid><pubDate>Mon, 04 Mar 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;순수 함수란 무엇인가?&lt;/h2&gt;
&lt;p&gt;순수 함수란 사이드 이펙트가 없는 함수, 즉 함수의 실행이 외부에 영향을 끼치지 않는 함수를 뜻하고 입력으로 전달된 값을 수정하지 않는 불변성을 가지고 있다. 따라서 순수함수는 어떠한 전달인자가 주어지더라도 항상 똑같은 값이 리턴됨을 보장한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;사이드 이펙트를 만들지 않는다.&lt;/strong&gt; 함수는 입력받은 값만을 가지고 결과를 반환하며, 그 외 어떤 외부 상태도 변경하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;동일 입력, 동일 출력.&lt;/strong&gt; 동일한 입력에 대해 순수 함수는 언제나 동일한 결과를 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;사이드 이펙트란?&lt;/h3&gt;
&lt;p&gt;함수의 입력 외에도 함수의 결과에 영향을 미치는 요인이다. 대표적으로 네트워크 요청,&lt;br&gt;
API 호출이 side effect이다.&lt;/p&gt;
&lt;h3&gt;순수 함수 개념이 중요한 이유는?&lt;/h3&gt;
&lt;p&gt;사이드 이펙트를 줄이고, 모듈화 수준을 높이는 함수형 프로그래밍의 특징, 즉 순수 함수는 평가 시점이 무관하다는 특징으로 인해 효율적인 로직을 구성할 수 있다.&lt;/p&gt;
&lt;h2&gt;React에서의 순수 컴포넌트란?&lt;/h2&gt;
&lt;p&gt;React는 순수 함수를 중심으로 설계되었다. 모든 컴포넌트가 순수 함수라고 가정한다.&lt;br&gt;
즉, 우리가 작성하는 React 컴포넌트는 동일한 입력이 주어졌을 때 항상 동일한 JSX를 반환해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://react-ko.dev/learn/keeping-components-pure&quot;&gt;https://react-ko.dev/learn/keeping-components-pure&lt;/a&gt;
&lt;a href=&quot;https://github.com/sudheerj/reactjs-interview-questions?tab=readme-ov-file#what-are-pure-components&quot;&gt;https://github.com/sudheerj/reactjs-interview-questions?tab=readme-ov-file#what-are-pure-components&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이어서....&lt;/p&gt;</content:encoded></item><item><title><![CDATA[🔧 로그인 로직 이해하기]]></title><description><![CDATA[로그인을 구현할 때 어떤 방법이 있을까? 프론트엔드에서 로그인을 구현하는 방법에는 여러 가지가 있다. 세션 기반 인증 : 사용자가 로그인을 하면 서버는 사용자의 정보를 세션에 저장하고, 클라이언트에 세션 ID…]]></description><link>https://leedawnn.github.io/login-logics/</link><guid isPermaLink="false">https://leedawnn.github.io/login-logics/</guid><pubDate>Wed, 28 Feb 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;로그인을 구현할 때 어떤 방법이 있을까?&lt;/h2&gt;
&lt;p&gt;프론트엔드에서 로그인을 구현하는 방법에는 여러 가지가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;세션 기반 인증&lt;/strong&gt; : 사용자가 로그인을 하면 서버는 사용자의 정보를 세션에 저장하고, 클라이언트에 세션 ID를 쿠키로 전송한다. 클라이언트는 이 쿠키를 보관하고 있다가 다음 요청 시 쿠키를 함께 보내 서버에서 인증을 받는다. 서버는 세션 ID를 통해 사용자의 정보를 찾아 인증한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;토큰 기반 인증 (jwt ..)&lt;/strong&gt; : 사용자가 로그인을 하면 서버는 사용자의 정보를 토큰에 담아 클라이언트에게 전송한다. 클라이언트는 이 토큰을 보관하고 있다가 다음 요청 시 토큰을 함께 보내 서버에서 인증을 받는다. 서버는 토큰을 해독해 사용자의 정보를 확인하고 인증한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OAuth&lt;/strong&gt; : 사용자가 이미 가입한 다른 서비스의 계정을 이용해 로그인하는 방법이다. 예를 들어, 구글이나 페이스북(meta) 계정으로 로그인하는 것이 이에 해당한다. 이 방식은 OAuh 프로토콜을 사용하며, 사용자가 서비스에 개인 정보를 제공하는 것 없이도 인증을 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Firebase Auth&lt;/strong&gt; : Firebase는 인증에 필요한 백엔드 서비스를 제공한다. 클라이언트 단에서 REST API를 사용하기만 하면 인증을 구현할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OAuth와 같은 다른 서비스를 이용하여 인증을 구현하는 방식을 제외하고, JWT와 세션을 이용한 로그인 로직에 대해 알아보자.&lt;/p&gt;
&lt;h2&gt;JWT (JSON Web Token)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;구현 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 로그인에 성공하면 서버에서 JWT를 생성하여 사용자에게 반환한다.&lt;/li&gt;
&lt;li&gt;사용자는 이 JWT를 클라이언트 측에 저장하고, 이후 요청에 대해 HTTP 헤더에 포함시켜 인증한다.&lt;/li&gt;
&lt;li&gt;서버는 이 토큰을 디코딩하여 유효성을 검증하고 요청을 처리한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서버 측에서 세션 상태를 유지할 필요가 없으므로 Stateless하고 확장성이 좋다.&lt;/li&gt;
&lt;li&gt;또한, 토큰은 클라이언트 측에서 저장되므로 서버의 부하를 줄일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JWT는 상대적으로 크기가 크므로, 매 요청마다 토큰을 포함시켜 보내야 하기 때문에 네트워크 부하가 생길 수 있다.&lt;/li&gt;
&lt;li&gt;또한, 한번 발급된 토큰은 유효기간이 만료될 때까지 계속 유효하므로 보안 문제가 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;세션&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;구현 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 로그인에 성공하면 서버에서 세션 ID를 생성하여 사용자에게 반환한다.&lt;/li&gt;
&lt;li&gt;이 세션 ID와 매칭되는 사용자 정보를 서버에 저장한다.&lt;/li&gt;
&lt;li&gt;사용자는 이후 요청에 대해 세션 ID를 포함시켜 서버에 전송하고, 서버는 이 세션 ID를 통해 사용자를 식별한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자 정보는 서버에 저장되므로, 보안성이 상대적으로 높다.&lt;/li&gt;
&lt;li&gt;서버에서 사용자의 상태 정보를 관리하므로 상세한 컨트롤이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자가 많아질수록 서버의 메모리를 많이 차지하게 되므로 확장성에 문제가 생길 수 있다.&lt;/li&gt;
&lt;li&gt;서버 기반의 인증 방식이므로 서버의 부하가 증가할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[🚀 React에서 컴포넌트를 분리하는 기준]]></title><description><![CDATA[컴포넌트를 분리하는 방법에는 어떤 것이 있을까? 컴포넌트를 분리하는 방법론들에 따라, 컴포넌트를 분리하는 "기준"이 달라지게 된다. 보통 컴포넌트를 분리하는 방법론은 아래와 같이 나뉜다. 컴포넌트의 관심사 분리(Separation of Concerns…]]></description><link>https://leedawnn.github.io/react-components/</link><guid isPermaLink="false">https://leedawnn.github.io/react-components/</guid><pubDate>Mon, 26 Feb 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;컴포넌트를 분리하는 방법에는 어떤 것이 있을까?&lt;/h2&gt;
&lt;p&gt;컴포넌트를 분리하는 방법론들에 따라, 컴포넌트를 분리하는 &quot;기준&quot;이 달라지게 된다.&lt;br&gt;
보통 컴포넌트를 분리하는 방법론은 아래와 같이 나뉜다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;컴포넌트의 관심사 분리(Separation of Concerns, SoC)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;headless 컴포넌트&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOLID, 단일 책임의 원칙&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 방법론들은 각각 어떤 기준을 가지고 있는지 하나씩 알아보자.&lt;/p&gt;
&lt;h2&gt;컴포넌트의 관심사 분리(Separation of Concerns, SoC)&lt;/h2&gt;
&lt;h3&gt;관심사의 분리란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;관심사의 분리란 복잡한 코드를 비슷한 기능을 하는 코드끼리 별도로 관리하는 것을 말한다.&lt;/li&gt;
&lt;li&gt;프로그램을 구별된 &apos;개개의 관심사를 해결하는 부분&apos;으로 분리하는 디자인 원칙이다.&lt;/li&gt;
&lt;li&gt;컴포넌트 별로 관심사를 분리하면 확장성과 재사용성을 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;컴포넌트를 분리하는 이유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;컴포넌트는 의도에 따라 &lt;strong&gt;UI를 표현&lt;/strong&gt;하고자 하거나 &lt;strong&gt;동작하는 로직&lt;/strong&gt;을 담을 수 있다.&lt;/li&gt;
&lt;li&gt;이처럼 컴포넌트는 재사용할 수 있는 최소 UI 단위임에도 불구하고, 웹의 복잡도와 해당 컴포넌트에서 수행하려고 하는 역할에 따라 얼마든지 복잡해질 수 있다.&lt;/li&gt;
&lt;li&gt;따라서 &apos;관심사의 분리&apos; 원칙에 따라 컴포넌트를 분리해서 관리하여야 한다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>